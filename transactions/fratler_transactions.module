<?php
// vim:fenc=utf-8:ft=php:ai:si:ts=2:sw=2:et:nu:fdm=indent:fdn=1:
/**
 * @file
 * A bookkeping solution; part of the fratler-Suite (www.fratler.de)
 * (c) 2013 Daniel Zauner aka dTatham the Horibble
 */


/**
 * Implements hook_permission()
 * @return
 *   The fully rendered permissions.
 *
 * @see _fac_permission_render()
 * @see FAcPerm
 */
function fratler_transactions_permission() {
  return _fac_permission_render(FAcPerm::ALL_TRANS);
}

/**
 * Implements hook_menu()
 */
function fratler_transactions_menu() {
  $items = array();

  $items['admin/config/fratler/transactions'] = array(
    'title'    => 'Fratler Transactions',
    'description'  => 'Configure the transaction entity of the fratler_suite',
    'page callback'  => 'drupal_get_form',
    'page arguments' => array('fratler_transactions_admin'),
    'access arguments' => array('access administration pages'),
    'file'    => 'ft_admin.inc',
  );

   $items['fratler/transaction/transfer'] = array(
    'title'    => 'New transfer',
    'description'  => 'Make a new transaction',
    'page callback'  => 'drupal_get_form',
    'page arguments' => array('fm_transaction_form', entity_get_controller('fratler_transaction')->create(), 'transfer'),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FacPerm::TRANSFER'),
    'type'    => MENU_LOCAL_TASK,
    'file'    => 'ft_transaction.inc',
    'weight'  => 2,
    'tab_root'  => 'fratler/account',
    'tab_parent'  => 'fratler/account',
  );

  $items['fratler/transaction/adjustment'] = array(
    'title'    => 'Adjust account',
    'description'  => 'Adjust an account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fm_transaction_form', entity_get_controller('fratler_transaction')->create(), 2),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::ADJUST'),
    'type'    => MENU_LOCAL_TASK,
    'weight'  => 3,
    'file'    => 'ft_transaction.inc',
    'tab_root'  => 'fratler/account',
    'tab_parent'  => 'fratler/account',
  );

  // Views
  // Transaction-singlet
  $items['fratler/transaction/%fratler_transaction'] = array(
    'title'    => 'View transaction',
    'description'  => 'Display a single transaction',
    'page callback'  => 'fratler_transaction_display',
    'page arguments' => array(2),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::DISPLAY', null, 2),
    'type'          => MENU_LOCAL_TASK,
    'context'       => MENU_CONTEXT_INLINE,
    'tab_root'      => 'fratler/account',
    'tab_parent'  => 'fratler/account',
  );
  // All transactions
  $items['fratler/account/all/statement'] = array(
    'title'    => 'All transactions',
    'description'  => 'Display all transactions',
    'page callback'  => 'fratler_transaction_statement',
    'page arguments' => array(2),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::DISPLAY_ALL'),
    'type'    => MENU_LOCAL_TASK,
    'weight'  => 91,
    'tab_parent'      => 'fratler/account',
  );
  // Personal statement
  $items['fratler/account/statement'] = array(
    'title'    => 'Statement',
    'description'  => 'View your account statement',
    'page callback' => 'fratler_transaction_statement',
    'page arguments' => array(),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::DISPLAY'),
    'type'    => MENU_LOCAL_TASK,
    'weight'  => 1,
    'menu_name'  => 'user-menu',
    'tab_parent'      => 'fratler/account',
    'tab_root'      => 'fratler/account',
  );
  // Statement
  $items['fratler/account/%fratler_account/statement'] = array(
    'title'    => 'Statement',
    'description'  => 'View your account statement',
    'page callback' => 'fratler_transaction_statement',
    'page arguments' => array(2),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::DISPLAY', 2),
    'type'    => MENU_LOCAL_TASK,
    'context'  => MENU_CONTEXT_INLINE,
    'tab_parent'      => 'fratler/account',
  );
   // Personal statement
  $items['user/%fratler_account/fratler_statement'] = array(
    'title'  => 'Account statement',
    'description'  => 'Account statement',
    'page callback'  => 'fratler_transaction_statement',
    'page arguments' => array(1),
    'access callback' => 'fratler_accounts_access',
    'access arguments' => array('FAcPerm::DISPLAY', 1),
    'type'    => MENU_LOCAL_TASK,
  );



  return $items;
}


/**
 * Fetches an array of all transactions an account-ID is involved in.
 *
 * @param aid
 * The account ID in question.
 *
 * @param tstamp
 *   A timestamp. If given, only transactions >= $tstamp will be returned.
 *
 * @return
 * An array holding all tids.
 */
function fratler_transactions_get_transactions($aid, $tstamp = null) {
  $query = db_select('fratler_transactions', 'f')
    ->fields('f', array('tid'))
    ->condition(db_or()->condition('rid', $aid)->condition('sid', $aid));
  if (!empty($tstamp))
    $query->condition('tstamp', $tstamp, '>=');

  $query->orderBy('tstamp', 'ASC');

#  dpq($query);

  return $query->execute()->fetchCol();
}

/**
 * Display a selected user's statement
 *
 * @param target
 *   The fully-loaded FMAc-object to display.
 *
 */
function fratler_transaction_statement($target = null) {
  global $user;
  if (!$target) 
    $target = fratler_account_load($user->uid);

  $style  = FMTransactionStyle::FM_STATEMENT;
        $rows  = array();

  // Override $style in case all transactions are displayed
  if ($target == 'all') 
    $style = FMTransactionStyle::FM_FULL;
  else 
    drupal_set_title($user->uid == $target->aid ? t('My account statement') : t('@name\'s account statement', array('@name' => $target->name)));

  $header = fratler_transactions_format_header($style);

  $query = db_select('fratler_transactions', 't')->orderBy('t.tstamp', 'DESC');

  if ($target == 'all')
    $query->where('(t.sid = 0) OR (t.sid != 0 AND t.amount > 0)');
  else
    $query->condition('rid', $target->aid);

  $count_query = clone $query;
  $count_query->addExpression('COUNT(t.tid)');

  $query = $query->extend('PagerDefault');
  $query->setCountQuery($count_query);
  // Because of the way transactions are handled, we need to swap rid/sid if required; this is also the reason why we can't use bloody EFQs...
  $query->addExpression('IF (t.amount < 0 AND t.sid != 0, t.sid, t.rid)', 'rid');
  $query->addExpression('IF (t.amount < 0 AND t.sid != 0, t.rid, t.sid)', 'sid');
  $query->leftJoin('fratler_accounts', 'look_sid', 't.sid = look_sid.aid');
  $query->leftJoin('fratler_accounts', 'look_rid', 't.rid = look_rid.aid');
  $query->addField('t', 'tid');
  $query->addField('look_sid', 'name', 'sid_name');
  $query->addField('look_rid', 'name', 'rid_name');
  $query->limit(variable_get('fac_pager'));

  // We're only interested in aids
  $result = $query->execute()->fetchCol();

  if ($result) {
    $transactions = fratler_transaction_load_multiple($result);

    foreach ($transactions as $transaction) {
      if ($target == 'all') 
        $transaction->balance_sid = fratler_account_get_balance($transaction->sid, $transaction->tstamp);
      $rows[] = fratler_transactions_format_row($transaction, $style);
    }
  }

  return array(

    'content'  => array(
      '#theme'  => 'table',
      '#header'  => $header,
      '#empty'        => t('No transactions available.'),
      '#rows'         => $rows,
      '#sticky'       => true,
      '#attributes'   => array('class' => array('fm_transaction')),
    ),
    'pager'    => array(
      '#markup'  => theme('pager'),
      '#weight'  => 10,
    ),
    'filter'  => drupal_get_form('fratler_transaction_statement_filter'),
  );
}

/**
 * Renders the filter for statement-pages; users with permission 'display other transactions' will see a textfield,
 * users with more than 1 account attached to them (-> Master Accounts) will see a dropdown box.
 */
function fratler_transaction_statement_filter($form, &$form_state) {
  $items = array();
  $aids = array();
  global $user;

  // Grab all the accounts the user can access
  foreach (module_implements('fac_get_accounts') as $module)
    foreach (module_invoke($module, 'fac_get_accounts', $user, 'display') as $aid => $account)
      $aids[$aid] = $account->name;
   
  natcasesort($aids);
  // If there's just 1 account the user can display: abort.
  if (count($aids) <= 1 && !fratler_accounts_access(FAcPerm::DISPLAY_ALL))
    return array();

  $items['cont'] = array(
    '#type'  => 'fieldset',
    '#title' => t('Switch accounts'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#attributes' => array('class' => array('container-inline')), 
  );
  if (fratler_accounts_access(FAcPerm::DISPLAY_ALL)) {
    $items['cont']['aname'] = array(
      '#type'    => 'textfield',
      '#title'  => t('Switch to:'),
      '#size'    => 20,
      '#autocomplete_path' => 'fratler/fac_autocomplete/all/all',
    );
    $items['aid'] = array(
      '#type'    => 'value',
      '#value'  => false,
    );
  }
  else 
    $items['cont']['aid'] = array(
      '#type'    => 'select',
      '#size'    => 1,
      '#options'  => $aids,
    );

  $items['cont']['submit'] = array(
    '#type'    => 'submit',
    '#value'  => t('Go'),
  );

  return $items;
}
/**
 * Parse the required account number, if necessary.
 */
function fratler_transaction_statement_filter_validate($form, &$form_state) {
  // Return the user where they came from if nothing was selected
  if (isset($form_state['values']['aname']) && !strlen($form_state['values']['aname'])) {
    form_set_error('aname', '');
  }
  // Parse account name and insert account-ID
  if (isset($form_state['values']['aname'])) {
    $acc = fratler_account_load_by_name($form_state['values']['aname']);
    if (!$acc)
      form_set_error('aname', t('Invalid account name.'));
    else
      form_set_value($form['aid'], $acc->aid, $form_state);
  }
}
/**
 * Redirects the user to the new account statement
 */
function fratler_transaction_statement_filter_submit($form, &$form_state) {
  $form_state['redirect'] = array('fratler/account/' . $form_state['values']['aid'] . '/statement');
}


/*
 * TODO give me brains
 */
function fm_transaction_filter_form($form, &$form_state) {
  $form['filters'] = array(
    '#type'   => 'fieldset',
    '#title'   => t('Filter transactions'),
    '#collapsible'  => true,
    '#theme'  => 'exposed_filters',
  );

  $form['filters']['cont_tstamp'] = array(
    '#type'    => 'fieldset',
    '#title'  => t('By timestamp'),
    '#collapsible'  => true,
    '#collapsed'  => true,
  );
  $form['filters']['cont_tstamp']['tstamp_date_from'] = array(
    '#type'    => 'date_select',
    '#title'  => t('From:'),
    '#date_format'  => variable_get('date_format_short', 'm/d/Y - H:i'),
    '#default_value' => date('Y-m-d H:i:s', time()-86400),
    '#date_label_position' => 'none',
  );
  $form['filters']['cont_tstamp']['tstamp_date_to'] = array(
    '#type'    => 'date_select',
    '#title'  => t('To:'),
    '#date_format'  => variable_get('date_format_short', 'm/d/Y - H:i'),
    '#default_value' => date('Y-m-d H:i:s', time()),
    '#date_label_position' => 'none',
  );
  $form['filters']['cont_acc'] = array(
    '#type'    => 'fieldset',
    '#title'  => t('By account'),
    '#collapsible'  => true,
    '#collapsed'  => true,
  );
  $form['filters']['cont_acc']['acc_sel'] = array(
    '#type'    => 'select',
    '#options'  => array('sid' => t('Sender'), 'rid' => t('Account', array(), array('context' => 'accounting'))),
    '#field_prefix'  => '<div class="fm_filter_label">',
    '#empty_value'  => 'all',
    '#empty_option'  => t('any'),
  );
  $form['filters']['cont_acc']['account'] = array(
    '#type'    => 'textfield',
    '#autocomplete_path' => 'fratler/fac_autocomplete',
    '#size'    => 20,
    '#field_suffix'  => '</div>',
  );

  $form['filters']['cont_ttype'] = array(
    '#type'    => 'fieldset',
    '#title'  => t('By type'),
    '#collapsible'  => true,
    '#collapsed'  => true,
  );

  $top_level = taxonomy_get_tree(variable_get('fm_vocab'), $parent = 0, 1);
  foreach ($top_level as $id => $term) {
    $options[$term->name] = array();
    $children = taxonomy_get_tree(variable_get('fm_vocab'), $term->tid);
    foreach ($children as $child) 
      $options[$term->name][$child->tid] = $child->name . " ($child->description)";
  }

  $form['filters']['cont_ttype']['ttype'] = array(
    '#type'    => 'select',
    '#title'  => t('Select type(s)'),
    '#multiple'  => true,
    '#options'  => $options,
  );

  $form['filters']['cont_txt'] = array(
    '#type'    => 'fieldset',
    '#title'  => t('By memo'),
    '#collapsible'  => true,
    '#collapsed'  => true,
  );
  $form['filters']['cont_txt']['txt'] = array(
    '#type'    => 'textfield',
  );

  $form['filters']['cont_am'] = array(
    '#type'    => 'fieldset',
    '#title'  => t('By amount'),
    '#collapsible'  => true,
    '#collapsed'  => true,
  );
  $form['filters']['cont_am']['amount_from'] = array(
    '#type'    => 'textfield',
    '#field_prefix'  => t('From:'),
    '#size'         => 8,
    '#default_value' => _fac_format_number(0),
    '#field_prefix' => '<span class="fm_filter_label">' . t('From:') . '</span> ' . _fac_cs_psfix(true, $fmt),
    '#field_suffix' => _fac_cs_psfix(false, $fmt),
    '#attributes'  => array('class' => array('fratler_amount')),
  );
  $form['filters']['cont_am']['amount_to'] = array(
    '#type'    => 'textfield',
    '#size'         => 8,
    '#default_value' => _fac_format_number(0),
    '#field_prefix' => '<span class="fm_filter_label">' . t('To:') . '</span> ' . _fac_cs_psfix(true, $fmt),
    '#field_suffix' => _fac_cs_psfix(false, $fmt),
    '#attributes'  => array('class' => array('fratler_amount')),
  );
  $form['filters']['actions'] = array(
    '#type'    => 'actions'
  );
  $form['filters']['actions']['submit'] = array(
    '#type'    => 'submit',
    '#value'  => t('Filter'),
  );
  $form['filters']['actions']['reset'] = array(
    '#type'    => 'submit',
    '#value'  => t('Reset'),
  );

  return $form;
}

/**
 * This is the page callback to display a single transaction.
 *
 * @param entity
 *   The fully loaded transaction entity.
 */
function fratler_transaction_display($entity = false, $style = FMTransactionStyle::FM_DEFAULT) {
  global $user;

  drupal_set_title(t('Transaction #@tid', array('@tid' => $entity->tid)));

  // If we're adjusting, replace FM_BAL_RID with FM_BAL_SID
  if ($entity->sid == 0) { 
    if ($style & FMTransactionStyle::FM_BAL_SID) $style ^= FMTransactionStyle::FM_BAL_SID;
    $style |= FMTransactionStyle::FM_BAL_RID;
  }
  
  // If the user is allowed to transfer others' amounts but not to display, cut out the balances. It's the polite thing to do.
  if (!fratler_accounts_access(FAcPerm::DISPLAY_ALL | FAcPerm::DISPLAY_ACC)) { 
    if ($style & FMTransactionStyle::FM_BAL_SID && $entity->sid != $user->uid && !fratler_accounts_access(FAcPerm::DISPLAY,NULL, $entity)) $style ^= FMTransactionStyle::FM_BAL_SID;
    if ($style & FMTransactionStyle::FM_BAL_RID && $entity->rid != $user->uid) $style ^= FMTransactionStyle::FM_BAL_RID;
  }
 
  return theme('table', array(
    'header'  => fratler_transactions_format_header($style),
    'empty'    => t('No transactions available.'),
    'rows'          => array(fratler_transactions_format_row($entity, $style)),
    'sticky'        => true,
    'attributes'    => array('class' => array('fm_transaction')),  
  ));
}

/**
 * Helper-Function to render a proper table row for a transaction-statement
 *
 * @paramt entity
 *   The transaction-singlet.
 *
 * @param format
 *   A bitfield that can be set to the required header-styles.
 *
 * @return
 *   An associative array with a properly formatted row.
 */
function fratler_transactions_format_row($entity, $format = FMTransactionStyle::FM_DEFAULT) {
  $row  = array();
  
  if ($format & FMTransactionStyle::FM_TID)
    $row['tid'] = array(
      'data'  => l($entity->tid, 'fratler/transaction/' . $entity->tid),
    );

  if ($format & FMTransactionStyle::FM_TSTAMP)
    $row['tstamp'] = array(
      'data'  => format_date($entity->tstamp, 'short'),
      'class' => array('ft_tstamp'),
    );

  if ($format & FMTransactionStyle::FM_SID)
    $row['sid'] = array(
      'data'  => $entity->sid == 0 ? t('-----') : (isset($entity->sid_name) ? $entity->sid_name : fratler_account_load($entity->sid)->name), 
    );

  if ($format & FMTransactionStyle::FM_RID) {
    $row['rid'] = array(
      'data'  => isset($entity->rid_name) ? $entity->rid_name : fratler_account_load($entity->rid)->name,
    );
  }

  if ($format & FMTransactionStyle::FM_TTYPE)
    $row['ttype'] = array(
      'data'  => isset($entity->ttype_name) ? $entity->ttype_name : taxonomy_term_load($entity->ttype)->name,
      'title'  => taxonomy_term_load($entity->ttype)->description,
    );

  if ($format & FMTransactionStyle::FM_TXT)
    $row['txt'] = array(
      'data'  => ($entity->iid ? t('By: @user', array('@user' => fratler_account_load($entity->iid)->name)) . '<br/>' : '') . filter_xss($entity->txt, array('br', 'em', 'strong','cite','b','i','u')),
      'class'  => array('fm_message'),
    );

  if ($format & FMTransactionStyle::FM_AMOUNT)
    $row['amount'] = array(
      'data'  => _fac_format_amount($entity->amount),
      'class' => array('fratler_amount'),
    );

  if ($format & FMTransactionStyle::FM_BAL_SID) 
    $row['balance_sid'] = array(
      'data'  => $entity->sid == 0 ? t('-----') : (isset($entity->balance_sid) ? _fac_format_amount($entity->balance_sid) : _fac_format_amount($entity->balance)),
      'class' => array('fratler_amount', (isset($entity->balance_sid) ? $entity->balance_sid : $entity->balance) < 0 ? 'fm_debit' : ''),
    );

  if ($format & FMTransactionStyle::FM_BAL_RID)
    $row['balance_rid'] = array(
      'data'  => isset($entity->balance_rid) ? _fac_format_amount($entity->balance_rid) : _fac_format_amount($entity->balance), 
      'class' => array('fratler_amount', (isset($entity->balance_rid) ? $entity->balance_rid : $entity->balance) < 0 ? 'fm_debit' : ''),
    );

  if ($entity->signature != false && $format & FMTransactionStyle::FM_SIGNATURE) {
    $row['fingerprint'] = array(
      'data'   => hash('crc32b', $entity->signature), 
      'title' => $entity->signature_ok ? t('Fingerprint valid') : t('Fingerprint invalid!'),
      'class'  => array('fm_fingerprint', !$entity->signature_ok ? 'fm_check_fail' : ''),
    );
    $row['sig_ok'] = array(
      'data'  => $entity->signature_ok ? '&#x2714'    : '&#x2718',
      'title' => $entity->signature_ok ? t('Fingerprint valid') : t('Fingerprint invalid!'),
      'class'  => $entity->signature_ok ? 'fm_check_ok'  : 'fm_check_fail',
    );
  }
  return $row;

}

/**
 * Helper-Function to generate the table-header for a transaction-statement
 *
 * @param format
 *   A bitfield that can be set to the required header-styles.
 *
 * @return
 *   An associative array with the properly formatted values.
 */
function fratler_transactions_format_header($format = FMTransactionStyle::FM_DEFAULT) {
  // Make things a bit easier
  $header   = array();

  if ($format & FMTransactionStyle::FM_TID)
    $header['tid'] = array(
      'data'    => t('#'),
      'title'    => t('Transaction-ID'),
      'type'    => 'property',
      'specifier'  => 'tid',
    );

  if ($format & FMTransactionStyle::FM_TSTAMP)
    $header['tstamp'] = array(
      'data'    => t('Timestamp'),
      'type'    => 'property',
      'sort'    => 'desc',
    );

  if ($format & FMTransactionStyle::FM_SID)
    $header['sid'] = array(
      'data'    => t('Sender'),
      'type'    => 'property',
    );

  if ($format & FMTransactionStyle::FM_RID)
    $header['rid'] = array(
      'data'    => t('Account', array(), array('context' => 'accounting')),
      'type'    => 'property',
    );

  if ($format & FMTransactionStyle::FM_TTYPE)
    $header['ttype'] = array(
      'data'    => t('Type'),
      'type'    => 'property',
    );

  if ($format & FMTransactionStyle::FM_TXT)
    $header['txt'] = array(
      'data'    => t('Transaction-Memo'),
      'class'    => array('fm_message'),
      'type'    => 'property',
    );

  if ($format & FMTransactionStyle::FM_AMOUNT)
    $header['amount'] = array(
      'data'    => t('Amount'),
      'type'    => 'property',
      'specifier'  => 'amount',
    );

  if ($format & FMTransactionStyle::FM_BAL_SID)
    $header['balance_sid'] = array(
      'data'    => $format & FMTransactionStyle::FM_BAL_RID ? t('New balance:<br/>Sender') : t('New balance'),
      'class'   => array('fm_multiheader'),
      'type'    => 'property',
      'specifier'  => 'balance',
    );

  if ($format & FMTransactionStyle::FM_BAL_RID)
    $header['balance_rid'] = array(
      'data'    => $format & FMTransactionStyle::FM_BAL_SID ? t('New balance:<br/>Account') : t('New balance'),
      'class'   => array('fm_multiheader'),
      'type'    => 'property',
      'specifier'  => 'balance',
    );

  if ($format & FMTransactionStyle::FM_SIGNATURE)
    $header['fingerprint'] = array(
      'data'  => t('Fingerprint'),
      'colspan' => 2,
    );

  return $header;
}

/**
 * The formatting-instructions for transaction-statements
 */
interface FMTransactionStyle {
  // Individual fields
  const FM_TID  = 1;
  const FM_TSTAMP = 2;
  const FM_SID  = 4;
  const FM_RID  = 8;
  const FM_TTYPE  = 16;
  const FM_TXT  = 32;
  const FM_AMOUNT  = 64;
  const FM_BAL_SID = 128;
  const FM_BAL_RID = 256;
  const FM_SIGNATURE = 512;

  // Sets
  const FM_DEFAULT   = 763;
  const FM_STATEMENT  = 895;
  const FM_FULL    = 1023;

  // Special
  const FM_SPLIT    = 2048;

}

/**
 * Load a Transaction-object.
 *
 * @param tid
 *   The Transaction-ID.
 *
 * @param reset
 *   Whether to reset the entity-cache.
 *
 * @return
 *   A fully-loaded Fratler Transaction object.
 */
function fratler_transaction_load($tid = NULL, $reset = FALSE) {
  $tids = (isset($tid) ? array($tid) : array());
  $transaction = fratler_transaction_load_multiple($tids, array(), $reset);
  return $transaction ? reset($transaction) : FALSE;
}

/**
 * Load multiple Transaction-objects.
 *
 * @param tids
 *   An array holding the Transaction-IDs.
 *
 * @param reset
 *   Whether to reset the entity-cache.
 *
 * @return
 *   A fully-loaded Fratler Transaction object.
 */
function fratler_transaction_load_multiple($tids = FALSE, $conditions = array(), $reset = FALSE) {
  return entity_load('fratler_transaction', $tids, $conditions, $reset);
}

/**
 * Wrapper to save a Transaction Entity.
 *
 * @param $entity
 *   The fully-populated Fratler Transaction Entity.
 */
function fratler_transaction_save(&$entity) {
  return entity_get_controller('fratler_transaction')->save($entity);
}


/**
 * Return the URI for a transaction.
 *
 * @param tid
 *   The transaction-ID to display.
 *
 * @return
 *   An associative array with the following elements:
 *   - 'path': The URL path for the entity.
 *   - 'options': (optional) An array of options for the url() function.
 *   The actual entity URI can be constructed by passing these elements to
 *   url(). 
 *
 */
function fratler_transaction_uri($tid) {
  return array(
    'path' => 'fratler/transaction/' . $tid,
  );
}

/**
 * FratlerTransactionControllerInterface definition
 *
 * This is the main hook for all transactions and while we're at it,
 * we'll define some handy functions.
 *
 * @see hook_entity_info_alter()
 */
interface FratlerTransactionControllerInterface
  extends DrupalEntityControllerInterface {
    public function create();
    public function save($entity);
    public function delete($entity);
  }

/**
 * FratlerTransactionController extends DrupalDefaultEntityController
 *
 * The data of all the transfers
 */
class FratlerTransactionController
  extends DrupalDefaultEntityController
  implements FratlerTransactionControllerInterface {

    /**
     * Create and return a new transaction-entity.
     */
    public function create() {
      $entity = new stdClass();
      $entity->tid  = 0;    // Transaction-ID
      $entity->rid  = 0;    // Recipient-ID
      $entity->sid  = 0;    // Sender-ID
      $entity->iid  = 0;    // Initiator-ID
      $entity->amount = 0;    // Amount... d'uh
      $entity->tstamp = 0;    // Timestamp  
      $entity->txt  = null;    // Transaction-Text
      $entity->ttype  = 0;    // Transaction-Type (taxonomy reference)
      $entity->signature = null;   // The transaction-checksum
      $entity->balance = 0;    // The recipient's balance after a successful transaction

      $entity->counter = TRUE;   // Whether we need a counter-transaction (false = adjustment)
      $entity->signature_ok = FALSE;  // I'm not a very trusting soul...
      return $entity;
    }

    /**
     * Save the entity-fields.
     */
    public function save($entity) {
      // Invoke hook_entity_presave().
      module_invoke_all('ft_transaction_presave', $entity);

      // 'primary_keys' is used to determine whether we're dealing with an update or 
      // a new entry. So, if the entry already has an ID, we'll specify 'tid' as the key.
      $primary_keys = $entity->tid ? 'tid' : array();

      // Write the whole shebang once to get the tid if we have none.
      if (empty($entity->tid))
        drupal_write_record('fratler_transactions', $entity, $primary_keys);

      // Now that we have the tid, add the hash to the existing record,
      // but only if the (previous) signature is OK.
      if ($entity->signature_ok) {
        // TODO insert watchdog
        $entity->signature = fratler_accounts_hash($entity);
        drupal_write_record('fratler_transactions', $entity, array('tid'));
      }

      // Invoke post-save hook_fm_transaction_update() or hook_fm_transaction_new().
      module_invoke_all(empty($entity->tid) ? 'ft_transaction_new' : 'ft_transaction_update', $entity);

      // Clear the static cache
      $this->resetCache(array($entity->tid));

      // Since it is essential that we update the accounts-database, this will not go through hooks.
      if ($entity->rid <> 0) {
        $account = fratler_account_load($entity->rid);
        $account->balance = $entity->balance;
        $account->last_trans = $entity->tid;
        $account->tstamp = $entity->tstamp;
        fratler_account_save($account);
      }


      // OK, we saved the original transaction; if we're to do a counter (and only if!!!), work some magic.
      if ($entity->counter) {
        $c_entity = clone $entity;
        // to prevent the loop of death.
        $c_entity->counter = !$entity->counter;  

        // Reset tid
        $c_entity->tid = 0;
        // Switch rid and sid
               $c_entity->rid = $entity->sid;
        $c_entity->sid = $entity->rid;
        // Invert amount
        $c_entity->amount = -$entity->amount;
        // Recalculate balance
        // TODO wouldn't it be quicker if we'd just load the account-object to get the balance?
        $c_entity->balance = number_format(fratler_account_get_balance($c_entity->rid) + $c_entity->amount, 2, '.', '');
        // Reset signature
        $c_entity->signature = 0;

        // And finally: shove it down this function again :)
        return $this->save($c_entity);
      }

      // Sanitize the object.
      unset($entity->counter);
      return $entity;
    }

    public function delete($entity) {
      $this->delete_multiple(array($entity));
    }

    /*
     * Since FM handles transaction from an account point of view, we need to swap rid / sid for counter-transactions
     */
    protected function buildQuery($ids, $conditions = array(), $revision_id = false) {
      $query = db_select('fratler_transactions', 'base')
        ->fields('base', array('tid', 'ttype', 'iid', 'txt', 'amount', 'balance', 'tstamp', 'signature'))
        ->condition('base.tid', $ids, 'IN');
      // Invert rid/sid if it's a counter booking
      $query->addExpression('IF (base.amount < 0 AND base.sid <> 0, base.sid, base.rid)', 'rid');
      $query->addExpression('IF (base.amount < 0 AND base.sid <> 0, base.rid, base.sid)', 'sid');

      // Grab the account names
      $query->leftJoin('fratler_accounts', 'look_sid', 'base.sid = look_sid.aid');
      $query->leftJoin('fratler_accounts', 'look_rid', 'base.rid = look_rid.aid');
      $query->addExpression('IF (base.amount<0 AND base.sid <> 0, look_sid.name, look_rid.name)', 'rid_name');
      $query->addExpression('IF (base.amount<0 AND base.sid <> 0, look_rid.name, look_sid.name)', 'sid_name');

      return $query;
    }

    /**
     * Loads the entity and does some cosmetics
     */
    public function load($ids = array(), $conditions = array(), $message = true) {
      $entities = parent::load($ids, array());
      foreach ($entities as $entity) {
        // Check the signature - it's gonna happen sooner or later anyways ;)
        $entity->signature_ok   = fratler_accounts_hash_verify($entity);

        // Clean up the account names and txt (avoid xss etc.)
        $entity->rid_name  = check_plain($entity->rid_name);
        $entity->sid_name  = check_plain($entity->sid_name);
        $entity->txt    = filter_xss($entity->txt, array('br', 'em', 'strong','cite','b','i','u'));

        // Attach a field with the transaction type - we'll need it probably
        $entity->ttype_name   = taxonomy_term_load($entity->ttype)->name;
      }
      return $entities;
    }

    /**
     * Transactions are not meant to be deleted at this stage, so this is just a stub
     */
    public function delete_multiple($entities) {
      debug('Transactions are not meant to be deleted. At the moment.');
    }
  }


function fratler_transactions_entity_info() {
  $info = array();
  $info['fratler_transaction'] = array(
    // Human readable label for the entity.
    'label'      => t('Transaction record'),

    // ControllerClass, an extension of the default drupal-controller.
    'controller class'  => 'FratlerTransactionController',

    // Base-Table. This one's pretty self-explanatory, huh?
    'base table'    => 'fratler_transactions',

    // Returns the URI-Eelements of an entity.
    // TODO: Read up on this one!
    'uri callback'    => 'fratler_transaction_uri',

    // At this point, we're not fiddling around with the fields.
    // TODO: assess feasibility of fieldabledness
    'fieldable'    => false,

    // entity_keys tell the controller, which field is used for keys-functions
    'entity keys'    => array(
      'id'  => 'tid',
    ),

    // We DO want the transactions to be cached, but not right now (for development-purposes)
    'static cache'    => true,

    // We don't make use of bundles (yet)
    'bundles'    => array(),
  );

  return $info;
}


/**
 * Implements hook_ft_transaction_dry_run()
 * Run a test on a given transaction. This function checks,
 * if the involved parties have all required permissions and 
 * if any of the set limits (overdraw, transaction volume etc.) are violated.
 * NOTE: this is only run once per transaction-set, so in case there's a 
 * counter-transaction, we need to make sure that the counter-transaction is
 * up to standards.
 *
 * @param entity
 *   The transaction-entity.
 *
 * @return
 *   An array of error-messages with the error-code as key and the corresponding field as value (which can be recycled by form_set_error() etc.
 */
function fratler_transactions_ft_transaction_dry_run($entity) {
  global $user;

  // Before we start, check the integrity of the balances-db
  // TODO still need a cron-job to keep an eye on the signatures in both databases!

  // Step 1: grab the involved accounts
  $rid = fratler_account_load($entity->rid);
  $sid = fratler_account_load($entity->sid);

  // Step 2: check the signatures of the involved accounts
  // If the signatures don't match, shit has officially hit the fan.
  if (!$rid->signature_ok)  {
    return array(FMErrors::SIGNATURE_MISMATCH => 'rid');
  }

  if ($sid && !$sid->signature_ok) 
    return array(FMErrors::SIGNATURE_MISMATCH => 'sid');


  // prepare the error-container
  $errors = array();

  // Check permissions for adjustments
  if (!$entity->counter) {
    if ($entity->rid == $user->uid && !fratler_accounts_access(FAcPerm::ADJUST_OWN))
      $errors[FMErrors::PERM_ADJ_OWN] = 'rid';
    else if ($entity->rid != $user->uid && !fratler_accounts_access(FAcPerm::ADJUST_OTHER))
      $errors[FMErrors::PERM_ADJ_OTH] = 'rid';
  }

  // Check, if rid and sid are identical
  if ($entity->rid == $entity->sid) 
    $errors[FMErrors::RIDSID_IDENTICAL] = 'rid';

  // Check if the user is allowed to transfer own/other funds.
  // This is only relevant for transfers 
  // TODO implement the same for master-accounts, as this one only checks uids
  if ($entity->counter && $entity->sid > 0) {
    if ($entity->sid == $user->uid && !fratler_accounts_access(FAcPerm::TRANSFER_OWN))
      $errors[FMErrors::PERM_TRANS_OWN] = 'sid';
    else if ($entity->sid != $user->uid && !fratler_accounts_access(FAcPerm::TRANSFER_ALL))
      $errors[FMErrors::PERM_TRANS_OTH] = 'sid';
  }

  // Check, if the recipient is allowed to receive transactions 
  // This only applies only for initial transfers, not the counter-transactions
  // TODO Make sure the implementation of FAcPerm in FMA ties in properly
  if ($entity->counter) {
    if (!fratler_accounts_access(FAcPerm::RECEIVE, $rid) && !fratler_accounts_access(FAcPerm::IGNORE_BAR)) {
      $errors[$rid->aid == $user->uid ? FMErrors::PERM_PART_OWN : FMErrors::PERM_PART_OTH] = 'rid';
    }
  }

  // If the amount is invalid or <= 0 and we're not adjusting
  if (!is_numeric($entity->amount) || ($entity->amount <= 0 && $entity->counter))
    $errors[FMErrors::AMOUNT_INVALID] = 'amount';

  // Check, if the amount exceeds the transaction-value and if the user's allowed to exceed it
  // fm_trans_max = 0 -> unlimited
  else if (abs($entity->amount) > variable_get('ft_trans_max') && variable_get('ft_trans_max') != 0 && 
      !fratler_accounts_access(FAcPerm::EXCEED_TRANS))
    $errors[FMErrors::AMOUNT_OVER_MAX] = 'amount';

  // Check the transaction-type for a pulse
  if (!taxonomy_term_load($entity->ttype))
    $errors[FMErrors::TTYPE_INVALID] = 'ttype';

  // Check for overdraw
  // If we're in a transfer and the sender overdraws (either < 0 or below the set overdraw-limit)
  // TODO: Implement the same for master-accounts as we're just doing the users here
  if ($entity->counter && $entity->sid > 0) {
    // Check if the sender is allowed to overdraw in general, in case the new balance is 0 > balance > limit
    if ($sid->balance-$entity->amount < 0 && $sid->balance-$entity->amount > variable_get('ft_overdraw_limit')) {
      if (!fratler_accounts_access(FAcPerm::OVERDRAW, $sid))
        $errors[$sid->aid == $user->uid ? FMErrors::OWN_OVERDRAW : FMErrors::SID_OVERDRAW] = 'amount';
    }
    // This is universal: check if the user has the permission to exceed the overdraw-limit
    if ($sid->balance-$entity->amount < variable_get('ft_overdraw_limit')) {
      if (!fratler_accounts_access(FAcPerm::EXCEED_OVERDRAW, $sid))
        $errors[$sid->aid == $user->uid ? FMErrors::OWN_OVERDRAW_EX : FMErrors::SID_OVERDRAW_EX] = 'amount';
    }

  // If we're adjusting and the recipient exceeds his overdraw
  // We're deducting -- this is to prevent deposits with the final balance still < overdraw_limit
  } else if (!$entity->counter && $entity->rid > 0 && $entity->amount < 0) {                  
    // Check if the user is allowed to overdraw in general, if the new balance is 0 > balance > limit
    if ($rid->balance+$entity->amount < 0 && $rid->balance+$entity->amount > variable_get('ft_overdraw_limit')) {
      if (!fratler_accounts_access(FAcPerm::OVERDRAW))
        $errors[FMErrors::OWN_OVERDRAW] = 'amount';
    }
    // This is universal: check if the user has permission to exceed the overdraw limit
    if ($rid->balance+$entity->amount < variable_get('ft_overdraw_limit')) {
      if (!fratler_accounts_access(FAcPerm::OVERDRAW))
        $errors[FMErrors::OWN_OVERDRAW_EX] = 'amount';
    }
  }

  return $errors;
}

/**
 * This holds the errors, that might occur during fm_dry_run()
 */
class FMErrors {
  const RIDSID_IDENTICAL   = 0;  // rid and sid are identical
  const PERM_TRANS_OWN  = 1;  // The user is not allowed to transfer own funds
  const PERM_TRANS_OTH  = 2;  // The user is not allowed to transfer others' funds
  const PERM_PART_OWN  = 3;  // The user may not participate in transaction-system
  const PERM_PART_OTH  = 4;  // The other involved user may not participate in transaction-system
  const PERM_ADJ_OWN  = 6;  // The user may not adjust the own account
  const PERM_ADJ_OTH  = 7;  // The user may not adjust other accounts

  const AMOUNT_INVALID  = 10;  // The amount is invalid
  const AMOUNT_OVER_MAX  = 11;  // The amount exceeds max. transaction-volume

  const SID_OVERDRAW  = 20;  // The transaction will overdraw the sender's account
  const RID_OVERDRAW  = 21;  // The adjustment will overdraw the recipient's account
  const OWN_OVERDRAW  = 22;  // The transaction will overdraw the user's account
  const SID_OVERDRAW_EX  = 23;  // The transaction will exceed the overdraw-limit
  const RID_OVERDRAW_EX  = 24;  // The adjustment will exceed the recipient's account
  const OWN_OVERDRAW_EX  = 25;  // The transaction will exceed the user's account

  const TTYPE_INVALID  = 30;  // The transaction-type is invalid

  const SIGNATURE_MISMATCH = 666; // Congratulations, you're fucked!

}

/**
 * Provides the corresponding string to an error-code.
 *
 * @see FMErrors
 *
 * @param error
 *   The error-code.
 *
 * @return
 *   The corresponding string passed through t().
 */
function ft_get_error($error) {
  switch ($error) {
    case FMErrors::RIDSID_IDENTICAL:  return t('Recipient and Sender must not be identical.');
    case FMErrors::PERM_TRANS_OWN:    return t('You are not allowed to transfer your own funds.');
    case FMErrors::PERM_TRANS_OTH:    return t('You are not allowed to transfer others\' funds.');
    case FMErrors::PERM_PART_OWN:    return t('You are not allowed to participate in transactions.');
    case FMErrors::PERM_PART_OTH:    return t('This account is not allowed to participate in transactions.');
    case FMErrors::PERM_ADJ_OWN:    return t('You are not allowed to adjust your own account.');
    case FMErrors::PERM_ADJ_OTH:    return t('You are not allowed to adjust other accounts.');

    case FMErrors::AMOUNT_INVALID:    return t('Amount invalid.');
    case FMErrors::AMOUNT_OVER_MAX:    return t('Amount exceeds maximum transaction value.');

    case FMErrors::SID_OVERDRAW:    return t('This transaction will overdraw the sender\'s account.');
    case FMErrors::SID_OVERDRAW_EX:    return t('This transaction will exceed the sender\'s overdraw-limit.');
    case FMErrors::RID_OVERDRAW:    return t('This transaction will overdraw the account.');
    case FMErrors::RID_OVERDRAW_EX:    return t('This transaction will exceed the account\'s overdraw-limit.');
    case FMErrors::OWN_OVERDRAW:    return t('This transaction will overdraw your account.');
    case FMErrors::OWN_OVERDRAW_EX:    return t('This transaction will exceed your overdraw-limit.');

    case FMErrors::TTYPE_INVALID:    return t('The transaction-type is invalid.');

    case FMErrors::SIGNATURE_MISMATCH:  ''; #return t('Signature mismatch detected. Please contact an administrator immediately!');

    default: return t('An unknown error occured. Your transaction could not be completed.');
  }
}


function fratler_transactions_reassign($master, $target, $redirect = null, $last_words = array()) {
  $merger = _fm_reassign_queue($master, $target, $last_words);
  if (!$merger) {
    error_log("ABORT ABORT ABORT!!!");
    return $redirect ? drupal_goto_redirect($redirect) : false;
  }
  $runner = array(
    'operations'   => $merger,
    'finished'  => '_fm_reassign_done',
    'title'    => t('Rebooking account %from to %to', array('%from' => $master->name, '%to' => $target->name)),
  );

  batch_set($runner);
  if  ($redirect)
    batch_process($redirect);
}

function _fm_reassign_queue($acc_from, $acc_to) {
  $merger = array();
  $sigs_ok = true;

  $tids_from = fratler_transactions_get_transactions($acc_from->aid);
  $transactions_from = fratler_transaction_load_multiple($tids_from);

  $tids_to = fratler_transactions_get_transactions($acc_to->aid, empty($transactions_from) ? array() : reset($transactions_from)->tstamp);
  $transactions_to = fratler_transaction_load_multiple($tids_to);

  // Since we get the counter-transactions inverted, we need to shift them back
  foreach ($transactions_to as $to) {
    if ($to->amount < 0 && $to->sid != 0)
      list($to->rid, $to->sid) = array($to->sid, $to->rid);

    $sigs_ok = $sigs_ok & $to->signature_ok;
  }

  foreach ($transactions_from as $from) {
    if ($from->amount < 0 && $from->sid <> 0) 
      list($from->rid, $from->sid) = array($from->sid, $from->rid);

    $sigs_ok = $sigs_ok & $from->signature_ok;
  }

  // If one of the signature checks failed, cancel the whole thing
  if (!$sigs_ok)
    return false;

  // Step 1: Initialize the context
  $merger[] = array(
    '_fm_reassign_process',
    array('op' => 'init', 
      array(
        'aid_from'   => $acc_from->aid,
        'name_from'  => $acc_from->name,
        'aid_to'   => $acc_to->aid, 
        'name_to'  => $acc_to->name,
        'tstamp_merge'  => time(),
        'balance_to'   => fratler_account_get_balance($acc_to->aid, empty($transactions_from) ? 0 : reset($transactions_from)->tstamp),
      ),
    ));
  if ($transactions_from) {
    foreach ($transactions_from as $key_from => $from) {
      // Attach the target account's transactions to the queue that need to be updated (stuff...)
      foreach ($transactions_to as $key_to => $to) {
        // Only transactions that affect the balance are relevant
        if ($to->tstamp <= $from->tstamp && $to->rid == $acc_to->aid) {
          $merger[] = array('_fm_reassign_process', array('op' => 'update', 'transaction' => $to));
          unset($transactions_to[$key_to]);
        }
      }

      $merger[] = array('_fm_reassign_process', array('op' => 'reassign', 'transaction' => $from));
      unset($transactions_from[$key_from]);
    }
    // Slap the remaining target transactions to the ops-array
    foreach ($transactions_to as $key => $to) {
      if ($to->rid == $acc_to->aid) {
        $merger[] = array('_fm_reassign_process', array('op' => 'update', 'transaction' => $to));
        unset($transactions_to[$key]);
      }
    }
  }

  // Last job: update the new account's balance
  $merger[] = array('_fm_reassign_process', array('op' => 'update_balances', null));

  return $merger;
}

function _fm_reassign_done($success, $results, $ops) {
  if ($success) {
    foreach ($results['messages'] as $message)
      drupal_set_message($message, 'status');
  }
  else
    drupal_set_message(t('Well... this is embarassing. Could not finish the job. Ask your admin for help. Sorry!'));
  
}

function _fm_reassign_process($op, $data, &$context) {
  global $user;

  // Set up context and fill it with the relevant data
  // aid_from  The old account id
  // name_from  The name of the new account
  // aid_to  The new account id
  // name_to  The name of the new account
  // balance_to  The last balance of the new account before the first transaction of the old account
  // tstamp_merge  The timestamp when the merge occured
  if ($op == 'init') {
    $context['results']['log']   = array();
    $context['results']['counter'][$data['name_to']]  = 0;
    $context['results']['conf']  = $data;
  }

  // Update the FMAcs 
  elseif ($op == 'update_balances') {
    $acc_from   = fratler_account_load($context['results']['conf']['aid_from']);
    $acc_to    = fratler_account_load($context['results']['conf']['aid_to']);

    // Reset old account
    $acc_from->last_trans = $acc_from->tstamp = $acc_from->balance = 0;
    fratler_account_save($acc_from);

    // Update new account
    $acc_to->balance   = $context['results']['conf']['balance_to'];
    $acc_to->tstamp   = $context['results']['conf']['tstamp_last'];
    $acc_to->last_trans   = $context['results']['conf']['tid_last'];
    fratler_account_save($acc_to);

    $context['results']['messages'][] = format_plural((int)$context['results']['counter'][$data['name_to']], 
        'Rebooked one transaction from %old to %new.', 
        'Rebooked @count transactions from %old to %new.',
        array('%old' => $context['results']['conf']['name_from'], '%new' => $context['results']['conf']['name_to']));
  }

  // Reassign a transaction to new account and do the necessary calculations
  elseif ($op == 'reassign') {
    // Old account was recipient; this means change rid and balance
    if ($data->rid == $context['results']['conf']['aid_from']) {
      $data->rid = $context['results']['conf']['aid_to'];
      $data->balance = $context['results']['conf']['balance_to'] = $context['results']['conf']['balance_to'] + $data->amount;
    }

    // The old account was the sender, all we need to do here is change the sid
    if ($data->sid == $context['results']['conf']['aid_from']) {
      $data->sid = $context['results']['conf']['aid_to'];
    }

    // If, by some freakish coincidence, we end up transferring stuff to the same account, reset the counter-balance (cosmetics only)
    if ($data->sid == $data->rid && $data->amount < 0)
      $data->balance = $context['results']['conf']['balance_to'];

    // Add a snappy message to let the user know what happened.
    $data->txt .= '<br/>'. t('[%old &#8594; %new on @date by @user]', 
      array('%old' => $context['results']['conf']['name_from'], 
        '%new' => $context['results']['conf']['name_to'], 
        '@date' => format_date($context['results']['conf']['tstamp_merge'], 'short'), 
        '@user' => format_username($user)));
    
    // We will save this at some point, but for now just dump it as log in $context
    fratler_transaction_save($data);
    $context['results']['log'][]  = array($op, $data);
    $context['results']['conf']['tstamp_last']  = $data->tstamp;
    $context['results']['conf']['tid_last']  = $data->tid;
    $context['results']['counter'][$data->name]++;
  }

  // Update the balance of the new account if necessary
  elseif ($op == 'update') {
    // Only transactions that affect the balance are relevant
    if ($data->rid == $context['results']['conf']['aid_to']) {
      $data->balance = $context['results']['conf']['balance_to'] = $context['results']['conf']['balance_to'] + $data->amount;
      fratler_transaction_save($data);
      $context['results']['log'][]  = array($op, $data);
      $context['results']['conf']['tstamp_last']  = $data->tstamp;
      $context['results']['conf']['tid_last']  = $data->tid;
      $context['results']['counter'][$data->name]++;
    }
  }

}
