<?php
/**
 * @file
 * A bookkeping solution; part of the fratler-Suite (www.fratler.de)
 * (c) 2013 Daniel Zauner aka dTatham the Horibble
 */

/**
 * Defines the Permission-Bitmastk.
 * 
 * FAcPerm::PARTICIPATE and FAcPerm::ALL are internal only.
 *
 * The corresponding drupal-permissions-array is rendered by _fac_permission_render().
 */
interface FAcPerm {
	// Display
	const DISPLAY_OWN	= 2;
	const DISPLAY_ALL	= 4;
	const DISPLAY_ACC	= 8;

	// Transactions
	const RECEIVE		= 16;
	const TRANSFER_OWN	= 32;
	const TRANSFER_ALL	= 64;
	const ADJUST_OTHER	= 128;
	const ADJUST_OWN	= 256;

	// Special permissions
	const OVERDRAW		= 512;
	const IGNORE_BAR	= 1024;
	const EXCEED_TRANS	= 2048;
	const EXCEED_OVERDRAW	= 4096;


	// Internal
	const PARTICIPATE	= 8192;
	const DISPLAY		= 6;
	const TRANSFER		= 96;
	const ADJUST		= 384;
	const ALL		= 8190;
}

/**
 * Render the drupal-permissions array.
 *
 * @param bitfield
 * 	The bitfield holding the permissions-data.
 *
 * @return
 * 	An array holding the rendered permissions, indexed by permission-system name.
 *
 * @see FAcPerm
 */
function _fac_permission_render($bitfield) {
	$permissions = array();

	if ($bitfield & FAcPerm::DISPLAY_OWN)
		$permissions['display own statement'] = array(
			'title'		=> t('Display own statement'),
			'key'		=> FAcPerm::DISPLAY_OWN,
		);
	if ($bitfield & FAcPerm::DISPLAY_ALL)
		$permissions['display all statements'] = array(
			'title'		=> t('Display all statements'),
			'key'		=> FAcPerm::DISPLAY_ALL,
		);
	if ($bitfield & FAcPerm::DISPLAY_ACC)
		$permissions['display accounts only'] = array(
			'title'		=> t('Display only accounts'),
			'description'	=> t('Allow the users to only display account-balances.'),
			'key'		=> FAcPerm::DISPLAY_ACC,
		);

	if ($bitfield & FAcPerm::RECEIVE)
		$permissions['receive transfers'] = array(
			'title'		=> t('Receive transfers'),
			'key'		=> FAcPerm::RECEIVE,
		);
	if ($bitfield & FAcPerm::TRANSFER_OWN)
		$permissions['transfer own funds'] = array(
			'title'		=> t('Transfer from own account'),
			'key'		=> FAcPerm::TRANSFER_OWN,
		);
	if ($bitfield & FAcPerm::TRANSFER_ALL)
		$permissions['transfer all funds'] = array(
			'title'		=> t('Transfer from all accounts'),
			'key'		=> FAcPerm::TRANSFER_ALL,
		);
	if ($bitfield & FAcPerm::ADJUST_OTHER)
		$permissions['adjust other accounts'] = array(
			'title'		=> t('Adjust other accounts'),
			'description'	=> t('Users may adjust any account but their own.'),
			'key'		=> FAcPerm::ADJUST_OTHER,
		);
	if ($bitfield & FAcPerm::ADJUST_OWN)
		$permissions['adjust own account'] = array(
			'title'		=> t('Adjust own account'),
			'description'	=> t('Users may adjust their own account.'),
			'key'		=> FAcPerm::ADJUST_OWN,
		);
	
	if ($bitfield & FAcPerm::OVERDRAW)
		$permissions['overdraw accounts'] = array(
			'title'		=> t('Overdraw accounts'),
			'description'	=> t('Users may overdraw accounts up to the system wide limit.'),
			'key'		=> FAcPerm::OVERDRAW,
		);
	if ($bitfield & FAcPerm::IGNORE_BAR)
		$permissions['ignore account bar'] = array(
			'title'		=> t('Ignore account-bar'),
			'description'	=> t('Users may conduct transactions with any account that aren\'t blocked by the syste (regardless of the account\'s permission).'),
			'key'		=> FAcPerm::IGNORE_BAR,
		);
	if ($bitfield & FAcPerm::EXCEED_TRANS)
		$permissions['exceed transaction limit'] = array(
			'title'		=> t('Exceed transaction limit'),
			'key'		=> FAcPerm::EXCEED_TRANS,
		);
	if ($bitfield & FAcPerm::EXCEED_OVERDRAW)
		$permissions['exceed overdraw limit'] = array(
			'title'		=> t('Exceed overdraw limit'),
			'key'		=> FAcPerm::EXCEED_OVERDRAW,
		);

	return $permissions;
}

/**
 * Calculates the permissions-bitmask out of a given user's permissions.
 *
 * @param user
 * 	A fully-loaded user object.
 */
function _fac_permission_calculate($user) {
	$status 	= 0;
	$all_permissions	= _fac_permission_render(FAcPerm::ALL);
	$user_roles 	= user_role_permissions($user->roles);

	$flattened	= array();
	array_walk_recursive($user_roles, function($a,$b) use (&$flattened) { $flattened[] = $b; });

	foreach ($flattened as $checkme) {
		if (array_key_exists($checkme, $all_permissions)) 
			$status |= $all_permissions[$checkme]['key'];
	}

	if ($status & FAcPerm::RECEIVE || $status & FAcPerm::TRANSFER || $status & FAcPerm::ADJUST || $status & FAcPerm::DISPLAY)
		$status |= FAcPerm::PARTICIPATE;

	return $status;

}

/**
 * Check the user-permissions against a context.
 *
 * @param context
 * 	The context to be checked.
 *
 * @param account
 * 	The fully-loaded FMAc-Object or NULL if the current user is to be checked.
 *
 * @param object
 * 	The object to be checked (if required).
 *
 * @return
 * 	TRUE if the account has sufficient permissions, otherwise FALSE.
 *
 * @see FAcPerm
 * @see user_access()
 */
function fratler_accounts_access($context, $account = NULL, $object = NULL) {
	global $user;
	$user_account = ($account && $account->is_own) ? $account : fratler_money_account_load($user->uid);

	// hook_menu() substitues integer values with paths, so we pass the constants as strings
	if (is_string($context))
		$context = constant($context);
	
	// TODO fumble in Master Accounts...
	// invoke hook_permission?


	// Scenario: Display account-overview (balances)
	// We're checking: aid == user->uid OR permission DISPLAY_ACC
	if ($context & FAcPerm::DISPLAY_ACC && $account) {
		return $account->is_own || $user_account->state & FAcPerm::DISPLAY_ACC || $user_account->state & FAcPerm::DISPLAY_ALL;
	}


	if (!$account)
		$account = $user_account;
	if (!$account) // In case no account was found, we have no business here.
		return false;

	// Check if the user is allowed to display stuff.
	// Check if the user can view other accounts ... TODO MASTER!!!
	if ($context & FAcPerm::DISPLAY && !$account->is_own && !$object) {
		return $user_account->state & FAcPerm::DISPLAY_ALL;
	}


	// When $object is given in context DISPLAY, a transaction is viewed.
	// Expects $context to be a fully-loaded transaction object.
	// All involved parties are allowed to see transaction-singlets.
	if ($context & FAcPerm::DISPLAY && $object) {
		// The user making a transaction always only gets to see the counter-transaction
		if ($object->amount < 0 && $object->sid != 0)
			return $object->sid == $account->aid;
		else
			return $object->rid == $account->aid || $object->iid == $account->aid;
	}
	if ($context & FAcPerm::ADJUST && $object) {
		if ($object->rid == $account->aid)
			return $account->state & FAcPerm::ADJUST_OWN;
		else
			return $account->state & FAcPerm::ADJUST_OTHER;
	}


	// Fallback: check if the account is permitted to do $context
	return $account->state & $context;
}

/**
 * Implements hook_permission()
 * @return
 * 	The fully rendered permissions.
 *
 * @see _fac_permission_render()
 * @see FAcPerm
 */
function fratler_money_permission() {
	return _fac_permission_render(FAcPerm::ALL);
}

/**
 * Implements hook_menu()
 */
function fratler_money_menu() {
	$items = array();


	// DEVEL SHIT
	$items['fratler/dev/perm'] = array(
		'title'		=> 'Permissions-Nukefield',
		'page callback'	=> '_fm_nuke_permission',
		'access callback' => true,
		'weight'	=> 100,
		'file'		=> 'fm_nukefield.inc',
		'menu_name'	=> 'user-menu',
	);

	// Admin-Page
	$items['admin/config/fratler/accounts'] = array(
		'title'		=> 'Fratler Money',
		'description'	=> 'Configure the bookkeeping entity of the fratler_suite',
		'page callback'	=> 'drupal_get_form',
		'page arguments' => array('fratler_money_admin_form'),
		'access arguments' => array('access administration pages'),
		'file'		=> 'fm_admin.inc',
	);
	// Rebuild accounts-table and permissiosn
	$items['admin/config/fratler/accounts/recreate_accounts'] = array(
		'title'		=> 'Recreate user accounts',
		'description'	=> 'Recreate user accounts',
		'page callback'	=> 'fratler_accounts_rebuild_permissions',
		'page arguments' => array('admin/config/fratler/accounts'),
		'access arguments' => array('access administration pages'),
		'type'		=> MENU_CALLBACK,
	);

	// Transactions
	$items['fratler/account'] = array(
		'title'		=> 'Fratler Account',
		'description'	=> 'Account overview, transfers',
		'page callback'	=> 'fm_account_overview',
		'page arguments' => array(null),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::PARTICIPATE'),
		'type'		=> MENU_NORMAL_ITEM,
		'menu_name'	=> 'user-menu',
	);
	$items['fratler/account/overview'] = array(
		'title'		=> 'Overview',
		'description'	=> 'Display account balances',
		'type'		=> MENU_DEFAULT_LOCAL_TASK,
		'weight'	=> 0,
	);
	$items['fratler/account/%fratler_money_account/overview'] = array(
		'title callback' => 'fm_account_overview_title',
		'title arguments' => array(2),
		'description'	=> 'Display account balances',
		'page callback'	=> 'fm_account_overview',
		'page arguments' => array(2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY_ACC', 2),
                'type'          => MENU_LOCAL_TASK,
		'context'       => MENU_CONTEXT_INLINE,
		'weight'	=> 0,
	);
 	$items['fratler/account/transfer'] = array(
		'title'		=> 'New transfer',
		'description'	=> 'Make a new transaction',
		'page callback'	=> 'drupal_get_form',
		'page arguments' => array('fm_transaction_form', entity_get_controller('fratler_money_transaction')->create(), 'transfer'),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FacPerm::TRANSFER'),
		'type'		=> MENU_LOCAL_TASK,
		'file'		=> 'fm_transaction.inc',
		'weight'	=> 2,
		'tab_root'	=> 'fratler/account',
		'tab_parent'	=> 'fratler/account',
	);

	$items['fratler/account/adjustment'] = array(
		'title'		=> 'Adjust account',
		'description'	=> 'Adjust an account',
		'page callback' => 'drupal_get_form',
		'page arguments' => array('fm_transaction_form', entity_get_controller('fratler_money_transaction')->create(), 2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::ADJUST'),
		'type'		=> MENU_LOCAL_TASK,
		'weight'	=> 3,
		'file'		=> 'fm_transaction.inc',
		'tab_root'	=> 'fratler/account',
		'tab_parent'	=> 'fratler/account',
	);

	// Views
	// Transaction-singlet
	$items['fratler/transaction/%fratler_money_transaction'] = array(
		'title'		=> 'View transaction',
		'description'	=> 'Display a single transaction',
		'page callback'	=> 'fm_display_transaction',
		'page arguments' => array(2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY', null, 2),
		'type'          => MENU_LOCAL_TASK,
		'context'       => MENU_CONTEXT_INLINE,
		'tab_root'      => 'fratler/account',
		'tab_parent'	=> 'fratler/account',
	);
	// All transactions
	$items['fratler/account/all/statement'] = array(
		'title'		=> 'All transactions',
		'description'	=> 'Display all transactions',
		'page callback'	=> 'fm_statement',
		'page arguments' => array(2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY_ALL'),
		'type'		=> MENU_LOCAL_TASK,
		'weight'	=> 91,
		'tab_parent'      => 'fratler/account',
	);
	// All accounts 
	$items['fratler/account/all/overview'] = array(
		'title'		=> 'All accounts',
		'description'	=> 'Display all transactions',
		'page callback'	=> 'fm_account_overview',
		'page arguments' => array(2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY_ACC'),
		'type'		=> MENU_LOCAL_TASK,
		'weight'	=> 90,
		'tab_parent'      => 'fratler/account',
	);
	// Personal statement
	$items['fratler/account/statement'] = array(
		'title'		=> 'Statement',
		'description'	=> 'View your account statement',
		'page callback' => 'fm_statement',
		'page arguments' => array(),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY'),
		'type'		=> MENU_LOCAL_TASK,
		'weight'	=> 1,
		'menu_name'	=> 'user-menu',
		'tab_parent'      => 'fratler/account',
		'tab_root'      => 'fratler/account',
	);
	// Statement
	$items['fratler/account/%fratler_money_account/statement'] = array(
		'title'		=> 'Statement',
		'description'	=> 'View your account statement',
		'page callback' => 'fm_statement',
		'page arguments' => array(2),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY', 2),
		'type'		=> MENU_LOCAL_TASK,
		'context'	=> MENU_CONTEXT_INLINE,
		'tab_parent'      => 'fratler/account',
	);
 	// Personal statement
	$items['user/%fratler_money_account/fm_statement'] = array(
		'title'	=> 'Account statement',
		'description'	=> 'Account statement',
		'page callback'	=> 'fm_statement',
		'page arguments' => array(1),
		'access callback' => 'fratler_accounts_access',
		'access arguments' => array('FAcPerm::DISPLAY', 1),
		'type'		=> MENU_LOCAL_TASK,
	);


	// CALLBACKS
	// User-Autocomplete
	// Wildcard order: direction (rid/sid), type (transfer/adjust), keywords
	$items['fratler/fm_autocomplete/%/%'] = array(
		'title'		=> 'User autocomplete',
		'page callback'	=> '_fm_autocomplete',
		'page arguments' => array(4, 2, 3),
		'access arguments' => array('access user profiles'),
		'type'		=> MENU_CALLBACK,
	);


	return $items;
}

/**
 * Rebuild the state (permissions) field in the FMAc table
 *
 * @param process
 * 	If set, batch_process() will be fired with $process as parameter.
 * 	NOTE: This also involves that "destination" must be set in the query.
 */

function fratler_accounts_rebuild_permissions($process = false) {
	$ops = array(
		'operations' 	=> array(array('_fac_build_perm_init', array())),
		'title'		=> t('Rebuilding Fratler Accounts'),
		'progress_message' => t('Processing account @current of @total.'),
		'finished'	=> '_fac_build_perm_done',
	);
	$users = user_load_multiple(false);
	unset($users[0]);
	foreach ($users as $user) {
		// Try to find the latest balance
		$balance = db_query('SELECT c.balance, c.tstamp, c.tid FROM {fratler_money_currents} c WHERE rid = :uid ORDER BY c.tstamp DESC LIMIT 1', array(':uid' => $user->uid))->fetchObject();
		$ops['operations'][] = array('_fac_build_perm_process', array($user, $balance));
	}
	batch_set($ops);

	if ($process) {
		$destination = drupal_get_destination();
		$url = 'admin/config/fratler/accounts';

		// If destination was set...
		if ($destination['destination'] != current_path())
			$url = $destination['destination'];

		batch_process($url);
	}
}

/**
 * Handle the results of the batch-call during fratler_money_install()
 *
 * @see fratler_money_enable()
 * @see batch_process()
 */
function _fac_build_perm_done($success = false, $results = null, $operations = null) {
	if ($success) {
		if ($results['created'])	drupal_set_message(format_plural($results['created'], 'Created one Transaction Account.', 'Created @count Transaction Accounts.'));
		if ($results['updated'])	drupal_set_message(format_plural($results['updated'], 'Updated one Transaction Account.', 'Updated @count Transaction Accounts.'));
	}
}

/**
 * Initializes the rebuild batch variables.
 * @see fratler_accounts_rebuild_permissions()
 */
function _fac_build_perm_init(&$context) {
	$context['results']['created'] = 0;
	$context['results']['updated'] = 0;
	$context['message'] = t('Initializing.');
}

/**
 * Runner-Task to create FMAcs for existing users and update the permissions.
 * @see fratler_accounts_rebuild_permissions()
 */
function _fac_build_perm_process($user, $balance, &$context) {
	$account = fratler_money_account_load($user->uid);
	if (!$account) 
		$account = entity_get_controller('fratler_money_account')->create($user->uid);

	$account->active = $user->status;
	$account->state  = _fac_permission_calculate($user);

	if ($balance) {
		$account->balance = $balance->balance;
		$account->tstamp = $balance->tstamp;
		$account->last_trans = $balance->tid;
	}
	$state = fratler_money_account_save($account);
	$context['message'] = t('Processing @account.', array('@account' => $account->name));
	$context['results'][$state == MergeQuery::STATUS_INSERT ? 'created' : 'updated']++;
}

/**
 * Fetches an array of all transactions an account-ID is involved in.
 *
 * @param aid
 * The account ID in question.
 *
 * @param tstamp
 * 	A timestamp. If given, only transactions >= $tstamp will be returned.
 *
 * @return
 * An array holding all tids.
 */
function fratler_money_get_transactions($aid, $tstamp = null) {
	$query = db_select('fratler_money_currents', 'f')
		->fields('f', array('tid'))
		->condition(db_or()->condition('rid', $aid)->condition('sid', $aid));
	if (!empty($tstamp))
		$query->condition('tstamp', $tstamp, '>=');

	$query->orderBy('tstamp', 'ASC');

#	dpq($query);

	return $query->execute()->fetchCol();
}
/**
 * Callback function to render the title of the overview-page
 *
 * @param $object
 * 	The fully-loaded FAc-object
 */
function fm_account_overview_title($object) {
	global $user;
	if ($object && $object == 'all')
		return t('All accounts');
	if (!$object)
		$object = fratler_money_account_load($user->uid);
	return $object->is_own ? t('My accounts') : t('Account overview: @name', array('@name' => $object->name));
}


/**
 * Display an overview of all accounts related to a given user.
 *
 * @param target
 * 	The fully-loaded FAc-object
 */
function fm_account_overview($target = null) {
	global $user;

	if (!$target)
		$target = fratler_money_account_load($user->uid);

	drupal_set_title(fm_account_overview_title($target));
	$rows = array();
	$accounts = array();

	// Grab all the accounts the user can see
	foreach (module_implements('fm_transaction_sids') as $module) {
		foreach (module_invoke($module, 'fm_transaction_sids', $target, null) as $account) {
			// Index the array by name, prefix own account with !! and Master Accounts with ZZ to weigh them up/down.
			if ($account->aid == $user->uid)
				$accounts[strtolower('!! ' . $account->name)] = $account;
			else if ($account->aid < 0)
				$accounts[strtolower('zz' . $account->name)] = $account;
			else
				$accounts[strtolower($account->name)] = $account; 
		}
	}
	ksort($accounts);

	// If we have account-IDs, process them
	if ($accounts) {
		// Verify and render the data
		foreach ($accounts as $account) {
			$rows[] = array(
				fratler_accounts_access(FAcPerm::DISPLAY, $account) ? l($account->name, 'fratler/account/' . $account->aid . '/statement') : $account->name,
				_fm_monetize($account->balance),
				$account->tstamp ? (fratler_accounts_access(FAcPerm::DISPLAY, $account) ? l(format_date($account->tstamp, 'short'), 'fratler/transaction/' . $account->last_trans) : format_date($account->tstamp, 'short')) : t('-----'),
				$account->active ? '&#x2714' : '&#x2718',
				$account->blocked ? '&#x2714' : '&#x2718',
				array('data' => hash('crc32b', $account->signature), 'class' => array('fm_fingerprint', !$account->signature_ok ? 'fm_check_fail' : '')),
				array('data' => $account->signature_ok ? '&#x2714' : '&#x2718', 'class' => array($account->signature_ok ? 'fm_check_ok' : 'fm_check_fail')),
			);
		}
	}

	$build = array(
		'#theme'	=> 'table',
		'#header'	=> array(t('Account'), t('Balance'), t('Last transaction'), t('Active'), t('Blocked'), array('data' => t('Fingerprint'), 'colspan' => 2)),
		'#rows'		=> $rows,
		'#sticky'	=> true,
		'#empty'	=> t('No accounts available.'),
		'#attributes'	=> array(
			'class'	=> array('fm_overview'),
		),
	);
	return $build;
}

/**
 * Display a selected user's statement
 *
 * @param target
 * 	The fully loaded user object to display.
 *
 */
function fm_statement($target = null) {
	global $user;
	if (!$target) 
		$target = fratler_money_account_load($user->uid);

	$style	= FMTransactionStyle::FM_STATEMENT;
        $rows	= array();

	// Override $style in case all transactions are displayed
	if ($target == 'all') 
		$style = FMTransactionStyle::FM_FULL;
	else 
		drupal_set_title($user->uid == $target->aid ? t('My account statement') : t('@name\'s account statement', array('@name' => fratler_money_format_account($target->aid))));

	$header = fratler_money_format_header($style);

	$query = db_select('fratler_money_currents', 't')->orderBy('t.tstamp', 'DESC');

	if ($target == 'all')
		$query->where('(t.sid = 0) OR (t.sid != 0 AND t.amount > 0)');
	else
		$query->condition('rid', $target->aid);

	$count_query = clone $query;
	$count_query->addExpression('COUNT(t.tid)');

	$query = $query->extend('PagerDefault');
	$query->setCountQuery($count_query);
	// Because of the way transactions are handled, we need to swap rid/sid if required; this is also the reason why we can't use bloody EFQs...
	$query->addExpression('IF (t.amount < 0 AND t.sid != 0, t.sid, t.rid)', 'rid');
	$query->addExpression('IF (t.amount < 0 AND t.sid != 0, t.rid, t.sid)', 'sid');
	$query->leftJoin('fratler_money_balances', 'look_sid', 't.sid = look_sid.aid');
	$query->leftJoin('fratler_money_balances', 'look_rid', 't.rid = look_rid.aid');
	$query->addField('t', 'tid');
	$query->addField('look_sid', 'name', 'sid_name');
	$query->addField('look_rid', 'name', 'rid_name');
	$query->limit(variable_get('fm_pager'));

	// We're only interested in aids
	$result = $query->execute()->fetchCol();

	if ($result) {
		$transactions = fratler_money_transaction_load_multiple($result);

		foreach ($transactions as $transaction) {
			if ($target == 'all') 
				$transaction->balance_sid = fm_get_balance($transaction->sid, $transaction->tstamp);
			$rows[] = fratler_money_format_row($transaction, $style);
		}
	}

	return array(
		'filter'	=> drupal_get_form('fm_statement_filter'),

		'content'	=> array(
			'#theme'	=> 'table',
			'#header'	=> $header,
			'#empty'        => t('No transactions available.'),
			'#rows'         => $rows,
			'#sticky'       => true,
			'#attributes'   => array('class' => array('fm_transaction')),
		),
		'pager'		=> array(
			'#markup'	=> theme('pager'),
			'#weight'	=> 10,
		),
	);
}

/**
 * Renders the filter for statement-pages; users with permission 'display other transactions' will see a textfield,
 * users with more than 1 account attached to them (-> Master Accounts) will see a dropdown box.
 */
function fm_statement_filter($form, &$form_state) {
	$items = array();
	$aids = array();

	// Grab all the accounts the user can access
	foreach (module_implements('fm_transaction_sids') as $module)
		foreach (module_invoke($module, 'fm_transaction_sids') as $aid => $account)
			$aids[$aid] = $account->name;
 	
	natcasesort($aids);
	// If there's just 1 account the user can display: abort.
	if (count($aids) <= 1 && !fratler_accounts_access(FAcPerm::DISPLAY_ALL))
		return array();

	$items['cont'] = array(
		'#type'	=> 'container',
		'#attributes' => array('class' => array('container-inline', 'fm_search_field')), 
	);
	if (fratler_accounts_access(FAcPerm::DISPLAY_ALL)) {
		$items['cont']['aname'] = array(
			'#type'		=> 'textfield',
			'#title'	=> t('Switch to:'),
			'#size'		=> 20,
			'#autocomplete_path' => 'fratler/fm_autocomplete/all/all',
		);
		$items['aid'] = array(
			'#type'		=> 'value',
			'#value'	=> false,
		);
	}
	else 
		$items['cont']['aid'] = array(
			'#type'		=> 'select',
			'#size'		=> 1,
			'#options'	=> $aids,
		);

	$items['cont']['submit'] = array(
		'#type'		=> 'submit',
		'#value'	=> t('Go'),
	);

	return $items;
}
/**
 * Parse the required account number, if necessary.
 */
function fm_statement_filter_validate($form, &$form_state) {
	// Return the user where they came from if nothing was selected
	if (isset($form_state['values']['aname']) && !strlen($form_state['values']['aname'])) {
		form_set_error('aname', '');
	}
	// Parse account name and insert account-ID
	if (isset($form_state['values']['aname'])) {
		$acc = fratler_money_account_load_by_name($form_state['values']['aname']);
		if (!$acc)
			form_set_error('aname', t('Invalid account name.'));
		else
			form_set_value($form['aid'], $acc->aid, $form_state);
	}
}
/**
 * Redirects the user to the new account statement
 */
function fm_statement_filter_submit($form, &$form_state) {
	$form_state['redirect'] = array('fratler/account/' . $form_state['values']['aid'] . '/statement');
}


/*
 * TODO give me brains
 */
function fm_transaction_filter_form($form, &$form_state) {
	$form['filters'] = array(
		'#type' 	=> 'fieldset',
		'#title' 	=> t('Filter transactions'),
		'#collapsible'	=> true,
		'#theme'	=> 'exposed_filters',
	);

	$form['filters']['cont_tstamp'] = array(
		'#type'		=> 'fieldset',
		'#title'	=> t('By timestamp'),
		'#collapsible'	=> true,
		'#collapsed'	=> true,
	);
	$form['filters']['cont_tstamp']['tstamp_date_from'] = array(
		'#type'		=> 'date_select',
		'#title'	=> t('From:'),
		'#date_format'	=> variable_get('date_format_short', 'm/d/Y - H:i'),
		'#default_value' => date('Y-m-d H:i:s', time()-86400),
		'#date_label_position' => 'none',
	);
	$form['filters']['cont_tstamp']['tstamp_date_to'] = array(
		'#type'		=> 'date_select',
		'#title'	=> t('To:'),
		'#date_format'	=> variable_get('date_format_short', 'm/d/Y - H:i'),
		'#default_value' => date('Y-m-d H:i:s', time()),
		'#date_label_position' => 'none',
	);
	$form['filters']['cont_acc'] = array(
		'#type'		=> 'fieldset',
		'#title'	=> t('By account'),
		'#collapsible'	=> true,
		'#collapsed'	=> true,
	);
	$form['filters']['cont_acc']['acc_sel'] = array(
		'#type'		=> 'select',
		'#options'	=> array('sid' => t('Sender'), 'rid' => t('Account')),
		'#field_prefix'	=> '<div class="fm_filter_label">',
		'#empty_value'	=> 'all',
		'#empty_option'	=> t('any'),
	);
	$form['filters']['cont_acc']['account'] = array(
		'#type'		=> 'textfield',
		'#autocomplete_path' => 'fratler/fm_autocomplete',
		'#size'		=> 20,
		'#field_suffix'	=> '</div>',
	);

	$form['filters']['cont_ttype'] = array(
		'#type'		=> 'fieldset',
		'#title'	=> t('By type'),
		'#collapsible'	=> true,
		'#collapsed'	=> true,
	);

	$top_level = taxonomy_get_tree(variable_get('fm_vocab'), $parent = 0, 1);
	foreach ($top_level as $id => $term) {
		$options[$term->name] = array();
		$children = taxonomy_get_tree(variable_get('fm_vocab'), $term->tid);
		foreach ($children as $child) 
			$options[$term->name][$child->tid] = $child->name . " ($child->description)";
	}

	$form['filters']['cont_ttype']['ttype'] = array(
		'#type'		=> 'select',
		'#title'	=> t('Select type(s)'),
		'#multiple'	=> true,
		'#options'	=> $options,
	);

	$form['filters']['cont_txt'] = array(
		'#type'		=> 'fieldset',
		'#title'	=> t('By memo'),
		'#collapsible'	=> true,
		'#collapsed'	=> true,
	);
	$form['filters']['cont_txt']['txt'] = array(
		'#type'		=> 'textfield',
	);

	$form['filters']['cont_am'] = array(
		'#type'		=> 'fieldset',
		'#title'	=> t('By amount'),
		'#collapsible'	=> true,
		'#collapsed'	=> true,
	);
	$form['filters']['cont_am']['amount_from'] = array(
		'#type'		=> 'textfield',
		'#field_prefix'	=> t('From:'),
		'#size'         => 8,
		'#default_value' => _fm_numerize(0),
		'#field_prefix' => '<span class="fm_filter_label">' . t('From:') . '</span> ' . _fm_cs_psfix(true, $fmt),
		'#field_suffix' => _fm_cs_psfix(false, $fmt),
		'#attributes'	=> array('class' => array('fm_amount')),
	);
	$form['filters']['cont_am']['amount_to'] = array(
		'#type'		=> 'textfield',
		'#size'         => 8,
		'#default_value' => _fm_numerize(0),
		'#field_prefix' => '<span class="fm_filter_label">' . t('To:') . '</span> ' . _fm_cs_psfix(true, $fmt),
		'#field_suffix' => _fm_cs_psfix(false, $fmt),
		'#attributes'	=> array('class' => array('fm_amount')),
	);
	$form['filters']['actions'] = array(
		'#type'		=> 'actions'
	);
	$form['filters']['actions']['submit'] = array(
		'#type'		=> 'submit',
		'#value'	=> t('Filter'),
	);
	$form['filters']['actions']['reset'] = array(
		'#type'		=> 'submit',
		'#value'	=> t('Reset'),
	);

	drupal_add_css(drupal_get_path('module', 'fratler_money') . '/styles/fratler_money_main.css');

	return $form;
}

/**
 * This is the page callback to display a single transaction.
 *
 * @param entity
 * 	The fully loaded transaction entity.
 */
function fm_display_transaction($entity = false, $style = FMTransactionStyle::FM_DEFAULT) {
	global $user;

	drupal_set_title(t('Transaction #@tid', array('@tid' => $entity->tid)));

	// If we're adjusting, replace FM_BAL_RID with FM_BAL_SID
	if ($entity->sid == 0) { 
		if ($style & FMTransactionStyle::FM_BAL_SID) $style ^= FMTransactionStyle::FM_BAL_SID;
		$style |= FMTransactionStyle::FM_BAL_RID;
	}
	
	// If the user is allowed to transfer others' amounts but not to display, cut out the balances. It's the polite thing to do.
	if (!fratler_accounts_access(FAcPerm::DISPLAY_ALL | FAcPerm::DISPLAY_ACC)) { 
		if ($style & FMTransactionStyle::FM_BAL_SID && $entity->sid != $user->uid) $style ^= FMTransactionStyle::FM_BAL_SID;
		if ($style & FMTransactionStyle::FM_BAL_RID && $entity->rid != $user->uid) $style ^= FMTransactionStyle::FM_BAL_RID;
	}

	// Make things pretty
	drupal_add_css(drupal_get_path('module', 'fratler_money') . '/styles/fratler_money_main.css');

	return theme('table', array(
		'header'	=> fratler_money_format_header($style),
		'empty'		=> t('No transactions available.'),
		'rows'          => array(fratler_money_format_row($entity, $style)),
		'sticky'        => true,
		'attributes'    => array('class' => array('fm_transaction')),	
	));
}

/**
 * Helper-Function to render a proper table row for a transaction-statement
 *
 * @paramt entity
 * 	The transaction-singlet.
 *
 * @param format
 * 	A bitfield that can be set to the required header-styles.
 *
 * @return
 * 	An associative array with a properly formatted row.
 */
function fratler_money_format_row($entity, $format = FMTransactionStyle::FM_DEFAULT) {
	$row	= array();
	
	if ($format & FMTransactionStyle::FM_TID)
		$row['tid'] = array(
			'data'	=> l($entity->tid, 'fratler/transaction/' . $entity->tid),
		);

	if ($format & FMTransactionStyle::FM_TSTAMP)
		$row['tstamp'] = array(
			'data'	=> format_date($entity->tstamp, 'short'),
		);

	if ($format & FMTransactionStyle::FM_SID)
		$row['sid'] = array(
			'data'	=> $entity->sid == 0 ? t('-----') : (isset($entity->sid_name) ? $entity->sid_name : fratler_money_format_account($entity->sid)), 
		);

	if ($format & FMTransactionStyle::FM_RID) {
		$row['rid'] = array(
			'data'	=> isset($entity->rid_name) ? $entity->rid_name : fratler_money_format_account($entity->rid),
		);
	}

	if ($format & FMTransactionStyle::FM_TTYPE)
		$row['ttype'] = array(
			'data'	=> isset($entity->ttype_name) ? $entity->ttype_name : taxonomy_term_load($entity->ttype)->name,
			'title'	=> taxonomy_term_load($entity->ttype)->description,
		);

	if ($format & FMTransactionStyle::FM_TXT)
		$row['txt'] = array(
			'data'	=> ($entity->iid ? t('By: @user', array('@user' => fratler_money_format_account($entity->iid))) . '<br/>' : '') . filter_xss($entity->txt, array('br', 'em', 'strong','cite','b','i','u')),
			'class'	=> array('fm_message'),
		);

	if ($format & FMTransactionStyle::FM_AMOUNT)
		$row['amount'] = array(
			'data'	=> _fm_monetize($entity->amount),
			'class' => array('fm_amount'),
		);

	if ($format & FMTransactionStyle::FM_BAL_SID) 
		$row['balance_sid'] = array(
			'data'	=> $entity->sid == 0 ? t('-----') : (isset($entity->balance_sid) ? _fm_monetize($entity->balance_sid) : _fm_monetize($entity->balance)),
			'class' => array('fm_amount', (isset($entity->balance_sid) ? $entity->balance_sid : $entity->balance) < 0 ? 'fm_debit' : ''),
		);

	if ($format & FMTransactionStyle::FM_BAL_RID)
		$row['balance_rid'] = array(
			'data'	=> isset($entity->balance_rid) ? _fm_monetize($entity->balance_rid) : _fm_monetize($entity->balance), 
			'class' => array('fm_amount', (isset($entity->balance_rid) ? $entity->balance_rid : $entity->balance) < 0 ? 'fm_debit' : ''),
		);

	if ($entity->signature != false && $format & FMTransactionStyle::FM_SIGNATURE) {
		$row['fingerprint'] = array(
			'data' 	=> hash('crc32b', $entity->signature), 
			'title' => $entity->signature_ok ? t('Fingerprint valid') : t('Fingerprint invalid!'),
			'class'	=> array('fm_fingerprint', !$entity->signature_ok ? 'fm_check_fail' : ''),
		);
		$row['sig_ok'] = array(
			'data'	=> $entity->signature_ok ? '&#x2714'		: '&#x2718',
			'title' => $entity->signature_ok ? t('Fingerprint valid') : t('Fingerprint invalid!'),
			'class'	=> $entity->signature_ok ? 'fm_check_ok'	: 'fm_check_fail',
		);
	}
	return $row;

}

/**
 * Helper-Function to generate the table-header for a transaction-statement
 *
 * @param format
 * 	A bitfield that can be set to the required header-styles.
 *
 * @param table_prefix
 * 	If the table will be sortable, which table-alias is used. Defaults to 't'.
 *
 * @return
 * 	An associative array with the properly formatted values.
 */
function fratler_money_format_header($format = FMTransactionStyle::FM_DEFAULT) {
	// Make things a bit easier
	$header 	= array();

	if ($format & FMTransactionStyle::FM_TID)
		$header['tid'] = array(
			'data'		=> t('#'),
			'title'		=> t('Transaction-ID'),
			'type'		=> 'property',
			'specifier'	=> 'tid',
		);

	// FIXME the key might need changing
	if ($format & FMTransactionStyle::FM_TSTAMP)
		$header['tstamp'] = array(
			'data'		=> t('Timestamp'),
			'type'		=> 'property',
			'sort'		=> 'desc',
		);

	if ($format & FMTransactionStyle::FM_SID)
		$header['sid'] = array(
			'data'		=> t('Sender'),
			'type'		=> 'property',
		);

	if ($format & FMTransactionStyle::FM_RID)
		$header['rid'] = array(
			'data'		=> t('Account'),
			'type'		=> 'property',
		);

	if ($format & FMTransactionStyle::FM_TTYPE)
		$header['ttype'] = array(
			'data'		=> t('Type'),
			'type'		=> 'property',
		);

	if ($format & FMTransactionStyle::FM_TXT)
		$header['txt'] = array(
			'data'		=> t('Transaction-Memo'),
			'class'		=> array('fm_message'),
			'type'		=> 'property',
		);

	if ($format & FMTransactionStyle::FM_AMOUNT)
		$header['amount'] = array(
			'data'		=> t('Amount'),
			'type'		=> 'property',
			'specifier'	=> 'amount',
		);

	if ($format & FMTransactionStyle::FM_BAL_SID)
		$header['balance_sid'] = array(
			'data'		=> $format & FMTransactionStyle::FM_BAL_RID ? t('New balance:<br/>Sender') : t('New balance'),
			'class' 	=> array('fm_multiheader'),
			'type'		=> 'property',
			'specifier'	=> 'balance',
		);

	if ($format & FMTransactionStyle::FM_BAL_RID)
		$header['balance_rid'] = array(
			'data'		=> $format & FMTransactionStyle::FM_BAL_SID ? t('New balance:<br/>Account') : t('New balance'),
			'class' 	=> array('fm_multiheader'),
			'type'		=> 'property',
			'specifier'	=> 'balance',
		);

	if ($format & FMTransactionStyle::FM_SIGNATURE)
		$header['fingerprint'] = array(
			'data'	=> t('Fingerprint'),
			'colspan' => 2,
		);

	return $header;
}

/**
 * The formatting-instructions for transaction-statements
 */
interface FMTransactionStyle {
	// Individual fields
	const FM_TID	= 1;
	const FM_TSTAMP = 2;
	const FM_SID	= 4;
	const FM_RID	= 8;
	const FM_TTYPE	= 16;
	const FM_TXT	= 32;
	const FM_AMOUNT	= 64;
	const FM_BAL_SID = 128;
	const FM_BAL_RID = 256;
	const FM_SIGNATURE = 512;

	// Sets
	const FM_DEFAULT 	= 763;
	const FM_STATEMENT	= 895;
	const FM_FULL		= 1023;

	// Special
	const FM_SPLIT		= 2048;

}

/**
 * Load a Transaction-object.
 *
 * @param tid
 * 	The Transaction-ID.
 *
 * @param reset
 * 	Whether to reset the entity-cache.
 *
 * @return
 * 	A fully-loaded Fratler Transaction object.
 */
function fratler_money_transaction_load($tid = NULL, $reset = FALSE) {
	$tids = (isset($tid) ? array($tid) : array());
	$transaction = fratler_money_transaction_load_multiple($tids, array(), $reset);
	return $transaction ? reset($transaction) : FALSE;
}

/**
 * Load multiple Transaction-objects.
 *
 * @param tids
 * 	An array holding the Transaction-IDs.
 *
 * @param reset
 * 	Whether to reset the entity-cache.
 *
 * @return
 * 	A fully-loaded Fratler Transaction object.
 */
function fratler_money_transaction_load_multiple($tids = FALSE, $conditions = array(), $reset = FALSE) {
	return entity_load('fratler_money_transaction', $tids, $conditions, $reset);
}

/**
 * Wrapper to save a Transaction Entity.
 *
 * @param $entity
 * 	The fully-populated Fratler Transaction Entity.
 */
function fratler_money_transaction_save(&$entity) {
	return entity_get_controller('fratler_money_transaction')->save($entity);
}

/**
* Generate the transaction-signature
*/
function fratler_money_hash($entity) {
	// Since we're modifying the entity, we need to pull a clone of the entity
	$entity = clone $entity;

	// We use the last digit of the timestamp as iteration
	return _fm_generate_hash($entity, _fm_generate_salt(substr($entity->tstamp, -1)));
}

/**
 * Verify the hash of a transaction / account.
 *
 * @param entity
 * 	The fully-loaded entity object with a populated signature element.
 *
 * @param message
 * 	Default: false. If message == true, fratler_money_hash_verify will issue a drupal_set_message informing the user about a mismatch.
 *
 * @return
 * 	TRUE if the signature checks out, FALSE if not.
 * 	In addition, a system (and optionally a user) message is fired.
 */
function fratler_money_hash_verify($entity) {
	// No signature? No party!
	if (!isset($entity->signature) || !$entity->signature)
		return false;

	$stored = $entity->signature;
	$entity = clone $entity;

	// If it's a counter-booking, swap rid/sid back
	if (isset($entity->sid) && $entity->sid != 0 && $entity->amount < 0)
		$entity->rid ^= $entity->sid ^= $entity->rid ^= $entity->sid;

	$verdict = _fm_generate_hash($entity, $stored) == $stored;

	// If there's a mismatch, start the bitching and screaming!
	if (!$verdict) {
		if (isset($entity->aid)) {
			watchdog('fratler_money', 'Signature-Mismatch for :user\'s account detected. Account has been locked. Your database might have been compromised!',
				array(':user' => check_plain($entity->name)),
				WATCHDOG_EMERGENCY,     // Yep. It's bad.
				l(t('Inspect account'), 'fratler/account/' . check_plain($entity->aid) . '/statement'));
			drupal_set_message(t('An error occured while verifying the signature of the account !name; ' . 
				'please contact an admin immediately.', 
				array('!name' => l(check_plain($entity->name), 'fratler/account/'.check_plain($entity->aid) . '/statement'))), 'error', false);
		}
		else {
			watchdog('fratler_money', 'Signature-Mismatch for transaction #:tid detected. Your database might have been compromised!',
				array(':tid' => check_plain($entity->tid)),
				WATCHDOG_EMERGENCY,
				l(t('Inspect transaction'), 'fratler/transaction/' . check_plain($entity->tid)));
			drupal_set_message(t('An error occured while verifying the signature for transaction #!tid. ' . 
				'Involved accounts were locked to avoid further corruption. ' .
				'Please contact an admin immediately.', 
				array('!tid' => l(check_plain($entity->tid), 'fratler/transaction/'.check_plain($entity->tid)))), 'error', false);

			debug("moo!!!");
			// Reset the FMAc signatures for the involved parties to prevent them from making a mess
			db_query('UPDATE {fratler_money_balances} SET blocked = 1, signature = NULL WHERE aid IN (:aids)', array(':aids' => array(check_plain($entity->rid), check_plain($entity->sid))));
			// Fire a hook, it might be a good idea to let the affected users know in some way...
			// TODO Implement an .api.module file describing all the hooks
			module_invoke_all('fm_account_block', check_plain($entity->rid));
			module_invoke_all('fm_account_block', check_plain($entity->sid));
		}
	}


	return $verdict;
}

/**
 * This is the internal hashing-function, inspired by drupal's _password_crypt().
 * The key difference is, that it's not truncated as the signature is stored as a blob.
 * And it looks fancy.
 *
 * @param entity
 * 	The transaction-entity
 *
 * @return
 * 	The salted hash or FALSE in case an error occured.
 */
function _fm_generate_hash($entity, $setting) {
	// Check the setting
	if ($setting[0] != '$' || $setting[2] != '$')
		return false;

	// Iteration-Counter
	static $itoa64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

	// Parse the iteration-counter
	$count_log2 = strpos($itoa64, $setting[3]);

	// Get and check salt
	$salt = substr($setting, 4, 8);
	if (strlen($salt) != 8) 
		return false;

	// Convert the base 2 log into an integer;
	$count = 1 << $count_log2;

	// Kill the stuff that can't be used for hashing
	unset($entity->signature, $entity->is_own, $entity->signature_ok, $entity->counter, $entity->balance_sid, $entity->balance_rid, $entity->sid_name, $entity->rid_name, $entity->ttype_name);


	// Do the hashy
	// Since drupal does not always respect the order of the entity-obejt, we'll convert the
	// entity back to an array, sort it by keys and do some necessary cosmetics.
	$data = get_object_vars($entity);
	if (isset($data['rid']))	$data['rid']		= (int) $data['rid'];
	if (isset($data['sid']))	$data['sid']		= (int) $data['sid'];
	if (isset($data['iid']))	$data['iid']		= (int) $data['iid'];
	if (isset($data['aid']))	$data['aid']		= (int) $data['aid'];
	if (isset($data['active']))	$data['active']		= (int) $data['active'];
	if (isset($data['state']))	$data['state']		= (int) $data['state'];
	if (isset($data['blocked']))	$data['blocked']	= (int) $data['blocked'];
	if (isset($data['amount'])) 	$data['amount'] 	= number_format($data['amount'], 2, '.', '');
	if (isset($data['balance'])) 	$data['balance'] 	= number_format($data['balance'], 2, '.', '');
	if (isset($data['tstamp'])) 	$data['tstamp'] 	= (int) $data['tstamp'];
	if (isset($data['last_trans']))	$data['last_trans']	= (int) $data['last_trans'];
	ksort($data);

	$hash = hash('sha512', $salt . json_encode($data), true);

	do {
		$hash = hash('sha256', $hash, true);
	} while (--$count);

	// In case $setting is an entire hash, just extract the first 12 bytes as setting-string
	$output = substr($setting, 0, 12) . $hash;
	return $output;

}

function _fm_generate_salt($count_log2) {
	$output = '$D$';		// We're modifying the hash-key; 'D' for Fratler - obvious, isn't it?
	$count_log2 = 5+$count_log2;	// This function expects the last byte of the timestamp, so a number between 0 and 9

	static $itoa64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
	$output .= $itoa64[$count_log2];	// Add the iteration-counter
	$output .= substr(base64_encode(drupal_random_bytes(6)), 0, 8);	// Get 8 entropy-bytes
	return $output;
}

/**
 * Return the URI for a transaction.
 *
 * @param tid
 * 	The transaction-ID to display.
 *
 * @return
 * 	An associative array with the following elements:
 * 	- 'path': The URL path for the entity.
 * 	- 'options': (optional) An array of options for the url() function.
 * 	The actual entity URI can be constructed by passing these elements to
 * 	url(). 
 *
 */
function fratler_money_transaction_uri($tid) {
	return array(
		'path' => 'fratler/transaction/' . $tid,
	);
}

/**
 * FratlerMoneyTransactionControllerInterface definition
 *
 * This is the main hook for all transactions and while we're at it,
 * we'll define some handy functions.
 *
 * @see hook_entity_info_alter()
 */
interface FratlerMoneyTransactionControllerInterface
	extends DrupalEntityControllerInterface {
		public function create();
		public function save($entity);
		public function delete($entity);
	}

/**
 * FratlerMoneyTransactionController extends DrupalDefaultEntityController
 *
 * The data of all the transfers
 */
class FratlerMoneyTransactionController
	extends DrupalDefaultEntityController
	implements FratlerMoneyTransactionControllerInterface {

		/**
		 * Create and return a new transaction-entity.
		 */
		public function create() {
			$entity = new stdClass();
			$entity->tid	= 0;		// Transaction-ID
			$entity->rid	= 0;		// Recipient-ID
			$entity->sid	= 0;		// Sender-ID
			$entity->iid	= 0;		// Initiator-ID
			$entity->amount = 0;		// Amount... d'uh
			$entity->tstamp = 0;		// Timestamp	
			$entity->txt	= null;		// Transaction-Text
			$entity->ttype	= 0;		// Transaction-Type (taxonomy reference)
			$entity->signature = null; 	// The transaction-checksum
			$entity->balance = 0;		// The recipient's balance after a successful transaction

			$entity->counter = true; 	// Whether we need a counter-transaction (false = adjustment)
			$entity->signature_ok = true;	// Signature is always OK in blank transactions.
			return $entity;
		}

		/**
		 * Save the entity-fields.
		 */
		public function save($entity) {
			// Invoke hook_entity_presave().
			module_invoke_all('fm_transaction_presave', $entity);

			// 'primary_keys' is used to determine whether we're dealing with an update or 
			// a new entry. So, if the entry already has an ID, we'll specify 'tid' as the key.
			$primary_keys = $entity->tid ? 'tid' : array();

			// Write the whole shebang once to get the tid if we have none.
			if (empty($entity->tid))
				drupal_write_record('fratler_money_currents', $entity, $primary_keys);

			// Now that we have the tid, add the hash to the existing record
			$entity->signature = fratler_money_hash($entity);
			drupal_write_record('fratler_money_currents', $entity, array('tid'));

			// Invoke post-save hook_fm_transaction_update() or hook_fm_transaction_new().
			module_invoke_all(empty($entity->tid) ? 'fm_transaction_new' : 'fm_transaction_update', $entity);

			// Clear the static cache
			$this->resetCache(array($entity->tid));

			// OK, we saved the original transaction; if we're to do a counter (and only if!!!), work some magic.
			if ($entity->counter) {
				$c_entity = clone $entity;
				// to prevent the loop of death.
				$c_entity->counter = !$entity->counter;	

				// Reset tid
				$c_entity->tid = 0;
				// Switch rid and sid
			       	$c_entity->rid = $entity->sid;
				$c_entity->sid = $entity->rid;
				// Invert amount
				$c_entity->amount = -$entity->amount;
				// Recalculate balance
				$c_entity->balance = number_format(fm_get_balance($c_entity->rid) + $c_entity->amount, 2, '.', '');
				// Reset signature
				$c_entity->signature = 0;

				// And finally: shove it down this function again :)
				return $this->save($c_entity);
			}

			return $entity;
		}

		public function delete($entity) {
			$this->delete_multiple(array($entity));
		}

		/*
		 * Since FM handles transaction from an account point of view, we need to swap rid / sid for counter-transactions
		 */
		protected function buildQuery($ids, $conditions = array(), $revision_id = false) {
			$query = db_select('fratler_money_currents', 'base')
				->fields('base', array('tid', 'ttype', 'iid', 'txt', 'amount', 'balance', 'tstamp', 'signature'))
				->condition('base.tid', $ids, 'IN');
			// Invert rid/sid if it's a counter booking
			$query->addExpression('IF (base.amount < 0 AND base.sid <> 0, base.sid, base.rid)', 'rid');
			$query->addExpression('IF (base.amount < 0 AND base.sid <> 0, base.rid, base.sid)', 'sid');

			// Grab the account names
			$query->leftJoin('fratler_money_balances', 'look_sid', 'base.sid = look_sid.aid');
			$query->leftJoin('fratler_money_balances', 'look_rid', 'base.rid = look_rid.aid');
			$query->addExpression('IF (base.amount<0 AND base.sid <> 0, look_sid.name, look_rid.name)', 'rid_name');
			$query->addExpression('IF (base.amount<0 AND base.sid <> 0, look_rid.name, look_sid.name)', 'sid_name');

			return $query;
		}

		/**
		 * Loads the entity and does some cosmetics
		 */
		public function load($ids = array(), $conditions = array(), $message = true) {
			$entities = parent::load($ids, array());
			foreach ($entities as $entity) {
				// Check the signature - it's gonna happen sooner or later anyways ;)
				$entity->signature_ok 	= fratler_money_hash_verify($entity, true);

				// Clean up the account names and txt (avoid xss etc.)
				$entity->rid_name	= check_plain($entity->rid_name);
				$entity->sid_name	= check_plain($entity->sid_name);
				$entity->txt		= filter_xss($entity->txt, array('br', 'em', 'strong','cite','b','i','u'));

				// Attach a field with the transaction type - we'll need it probably
				$entity->ttype_name 	= taxonomy_term_load($entity->ttype)->name;
			}
			return $entities;
		}

		/**
		 * Transactions are not meant to be deleted at this stage, so this is just a stub
		 */
		public function delete_multiple($entities) {
			debug('Transactions are not meant to be deleted. At the moment.');
		}
	}

/**
 * FratlerMoneyAccountController
 * defines the basic functions of the FMAc-Entity
 */
class FratlerMoneyAccountController 
	extends DrupalDefaultEntityController {

		/**
		 * Helper function: Determine the current name of the account
		 *
		 * @param aid
		 * 	The account-ID in question. If $aid > 0, user_load() is attempted. Else, a fratler_master_load() is run (if exists).
		 *
		 * @return
		 * 	The formatted account-name as string.
		 */
		public function formatFMAcName($aid) {
			$account = null;
			if ($aid > 0) {
				$account = user_load($aid);
				if ($account)
					return check_plain(format_username($account));		// D8: user_format_name()
			} else if (function_exists('fratler_master_load')) {
				$account = fratler_master_load($aid);
				if ($account)
					return check_plain($account->name);
			}

			return t('N/A');
		}

		/**
		 * Create and return a skeleton account
		 */
		public function create($aid = 0) {
			global $user;
			$account = new stdClass();
			$account->aid = $aid;	// The designated account-ID (userID or FMA-ID)
			$account->balance = 0.00;
			$account->active = 1;	// By default, all accounts are active. They only become inactive once the corresponding user/FMA has been deleted.
			$account->state = 0;	// Permissions-Bitfield.
			$account->blocked = 0;	// By default, all accounts are unblocked. They only become blocked if a signature-mismatch occurs.
			$account->name = $aid ? $this->formatFMAcName($aid) : null;
			$account->tstamp = 0;
			$account->last_trans = 0;	// tid of the last transaction
			$account->signature = fratler_money_hash($account);
			$account->signature_ok = true;
			$account->is_own = $account->aid == $user->uid;

			return $account;
		}

		public function save($account) {
			module_invoke_all('entity_presave', $account, 'fratler_money_account');

			$primary_keys = $account->aid ? 'aid' : array();

			// Resign the account if the previous signature was OK. If not, issue a warning and save with invalid signature to avoid masking manipulations.
			if ($account->signature_ok)
				$account->signature = fratler_money_hash($account);
			else {
				$account->blocked = 1;
				drupal_set_message(t('Signature of account !account\'s was corrupted. Changes were saved, but the signature was NOT updated. The account has been blocked to prevent further corruption.', 
							array('!account' => l(check_plain($account->name), 'fratler/account/' . $account->aid . '/statement'))), 'warning');
			}
			$state = db_merge('fratler_money_balances')
				->key(array('aid' => $account->aid))
				->fields(array(
					'balance'	=> $account->balance,
					'name'		=> check_plain($account->name),
					'active'	=> (int)$account->active,
					'state'		=> (int)$account->state,
					'blocked'	=> (int)$account->blocked,
					'tstamp'	=> $account->tstamp,
					'signature'	=> $account->signature,
					'last_trans'	=> $account->last_trans,
				))->execute();

			module_invoke_all(empty($primary_keys)? 'entity_insert' : 'entity_update', $account, 'fratler_money_account');

			return $state;
		}

		/**
		 * Load FMAc-object
		 *
		 * @param aids
		 * 	The array of FMAc-IDs.
		 *
		 * @param conditions
		 * 	Legacy; not used.
		 */
		public function load($aids = array(), $conditions = array()) {
			global $user;
			$accounts = parent::load($aids, $conditions);

			foreach ($accounts as $account) {
				$account->name 		= check_plain($account->name);
				$account->signature_ok	= fratler_money_hash_verify($account);
				$account->is_own	= $account->aid == $user->uid;
			}

			return $accounts;
		}

		/**
		 * Load an account by name
		 *
		 * @param name
		 * 	A string with the account name.
		 *
		 * @return
		 * 	A fully-loaded FMAc-object or FALSE if no match was found.
		 */
		public function loadByName($name) {
			$query = new EntityFieldQuery();
			$query->entityCondition('entity_type', 'fratler_money_account')
				->propertyCondition('name', $name);
			
			$result = $query->execute();
			$account = array();

			if (isset($result['fratler_money_account']) && count($result['fratler_money_account']) == 1)
				$account = $this->load(array_keys($result['fratler_money_account']));

			return reset($account);

		}

		public function delete($account) {
			$this->deleteMultiple(array($account));
		}
		public function deleteMultiple($accounts) {
			$aids = array();
			if (!empty($accounts)) {
				$transaction = db_transaction();

				try {
					foreach ($accounts as $account) {
						module_invoke_all('entity_delete', $account, 'fratler_money_account');
						$aids[] = $account->aid;
					}
					db_delete('fratler_money_balances')->condition('aid', $aids, 'IN')->execute();
				} catch (Exception $e) {
					$transaction->rollback();
					watchdog_exception('fratler_money', $e);
					throw $e;
				}
			}
		}

	}

/**
 * Implements hook_user_insert()
 * Create account-entries for new users.
 */
function fratler_money_user_insert(&$edit, $user, $category) {
	$account = entity_get_controller('fratler_money_account')->create($user->uid);
	$account->state = _fac_permission_calculate($user);
	fratler_money_account_save($account);
}
/**
 * Same as fratler_money_user_insert(). Catch changes to the username and/or status and adapt the FMAc accordingly.
 * @see fratler_money_user_insert()
 */
function fratler_money_user_update(&$edit, $user, $category) {
	$account = fratler_money_account_load($user->uid);
	if ($account) {
		$account->name = check_plain(format_username($user));
		$account->state = _fac_permission_calculate($user);
		$account->active = $user->status;
		fratler_money_account_save($account);
	}
}

/**
 * Handle deletion of users; Depending whether the user has already made transactions or not, either delete the FMAc entirely or set $account->active to false.
 * @see hook_user_delete()
 */
function fratler_money_user_delete($user) {
	$account = fratler_money_account_load($user->uid);
	if ($account) {
		if (count(fratler_money_get_transactions($account->aid)) == 0) {
			debug('Deleting FMAc.');
			fratler_money_account_delete($account);
		} else {
			$account->active = 0;
			fratler_money_account_save($account);
		}
	}
}

/**
 * Load a single account from storage.
 *
 * @param aid
 * 	The account-number.
 *
 * @param reset
 * 	Whether to reset the fratler_money_load_multiple cache.
 *
 * @return
 * 	A fully populated Account object or FALSE if nothing could be matched to $aid.
 */
function fratler_money_account_load($aid = null, $reset = false) {
	$aids = isset($aid) ? array($aid) : array();
	$account = fratler_money_account_load_multiple($aids, array(), $reset);
	return $account ? reset($account) : false;
}

/**
 * Load multiple accounts from storage.
 *
 * @param aids
 * 	An array of account-IDs
 *
 * @param conditions
 * 	-- legacy, not used --
 *
 * @param reset
 * 	Whether to reset the fratler_master_load_multiple cache.
 *
 * @return
 * 	An array of account objects indexed by mid.
 */
function fratler_money_account_load_multiple($aids = false, $conditions = array(), $reset = false) {
	return entity_load('fratler_money_account', $aids, $conditions, $reset);
}

/**
 * Load account by name.
 *
 * @param name
 * 	String with the account name.
 *
 * @return
 * 	A fully-loaded FMAc-object or FALSE if no match was found.
 */
function fratler_money_account_load_by_name($name) {
	return entity_get_controller('fratler_money_account')->loadByName($name);
}

/**
 * Save changes to an account (i.e. update the entry).
 * We'll just shove everything to the entity-handler
 *
 * @param account
 * 	The account to be saved / updated.
 */
function fratler_money_account_save(&$account) {
	return entity_get_controller('fratler_money_account')->save($account);
}

/**
 * Delete the FMAc
 *
 * @param account
 * 	The loaded account in question.
 */
function fratler_money_account_delete($account) {
	entity_get_controller('fratler_money_account')->delete($account);
}


function fratler_money_entity_info() {
	$info = array();
	$info['fratler_money_account'] = array(
		'label'			=> t('Fratler Money account'),
		'controller class'	=> 'FratlerMoneyAccountController',
		'base table'		=> 'fratler_money_balances',
		'uri callback'		=> 'fratler_money_account_uri',
		'fieldable'		=> false,
		'entity keys'		=> array(
						'id'	=> 'aid',
						'label'	=> 'name',
					),
				);
	$info['fratler_money_transaction'] = array(
		// Human readable label for the entity.
		'label'			=> t('Transaction record'),

		// ControllerClass, an extension of the default drupal-controller.
		'controller class'	=> 'FratlerMoneyTransactionController',

		// Base-Table. This one's pretty self-explanatory, huh?
		'base table'		=> 'fratler_money_currents',

		// Returns the URI-Eelements of an entity.
		// TODO: Read up on this one!
		'uri callback'		=> 'fratler_money_transaction_uri',

		// At this point, we're not fiddling around with the fields.
		// TODO: assess feasibility of fieldabledness
		'fieldable'		=> false,

		// entity_keys tell the controller, which field is used for keys-functions
		'entity keys'		=> array(
			'id'	=> 'tid',
		),

		// We DO want the transactions to be cached, but not right now (for development-purposes)
		'static cache'		=> true,

		// We don't make use of bundles (yet)
		'bundles'		=> array(),
	);

	return $info;
}

/**
 * Handle the aftermath of a transaction.
 *
 * @param entity
 * 	The transaction-entity of the transaction.
 */
function fratler_money_fm_transaction_update($entity) {
	$account		= fratler_money_account_load($entity->rid);
	$account->balance 	= $entity->balance;
	$account->tstamp 	= $entity->tstamp;	
	$account->last_trans	= $entity->tid;
	fratler_money_account_save($account);
}

/**
 * Implements hook_fm_transaction_sids(). Find every account-id that the user can get an overview / access.
 *
 * @param target
 * 	The user to be checked (ID or object); if none given the current user is checked.
 * 	If target 'all' is passed, this function will return all user-accounts (aid > 0).
 *
 * @param type
 * 	The transaction type; not used in this context.
 * 	TODO This might be a good idea to change it to a permission against which to check the individual accounts
 *
 * @return
 * 	If the target is allowed to participate, an array with userID=>fratler_money_format_account().
 * 	Otherwise an empty array is returned.
 */
function fratler_money_fm_transaction_sids($target = false, $type = false) {
	global $user;

	$matches = array();
	$output = array();

	if ($target == 'all') {
		$query = new EntityFieldQuery(); 
		$query->entityCondition('entity_type', 'fratler_money_account')
			->propertyCondition('aid', 0, '>');
		$query = $query->execute();
		if (isset($query['fratler_money_account']))
			$matches = fratler_money_account_load_multiple(array_keys($query['fratler_money_account']));
	}

	// If the target is empty or a user-object, load the corresponding account
	else if (!$target || isset($target->uid))
		$matches[] = fratler_money_account_load($user->uid);
	else if (!is_object($target))
		$matches[] = fratler_money_account_load($target);
	else if ($target && isset($target->aid))
		$matches[] = $target;

	// Only if the user is allowed to receive / transfer funds, this makes sense; 
	// For groups that were taken out of the rotation at some point, a case can be made to add 'display own transactions' to the list
	foreach ($matches as $match) {
		if ($match && fratler_accounts_access(FAcPerm::PARTICIPATE, $match))
			$output[$match->aid] = $match;
	}

	return $output;
}

/**
 * Create a NumberFormatter object
 *
 * @param int style
 * 	The format-style; if none given, NumberFormatter::CURRENCY is used.
 *
 * @param string locale
 * 	The locale in which the number should be formatted; if none is given,
 * 	the system-default fm_locale is used.
 *
 * @return
 * 	The number-formatter object
 */
function _fm_nf_init($style = NumberFormatter::CURRENCY, $locale = NULL) {
	return numfmt_create($locale ? $locale : variable_get('fm_locale', 'C'), $style);
}

/**
 * Helper-Function
 *
 * @param object fmt
 * 	The pre-initialized NumberFormatter object. If none given, initialize a new one.
 *
 * @return string
 * 	The currency symbol.
 */
function _fm_cs(&$fmt = NULL) {
	return numfmt_get_symbol($fmt ? $fmt : _fm_nf_init(), NumberFormatter::CURRENCY_SYMBOL);
}

/**
 * Formatter-Helper
 *
 * @param amount
 * 	The amount... d'uh
 *
 * @param object fmt
 * 	The pre-initialized NumberFormatter object. If none given, initialize a new one.
 *
 * @return string 
 * 	The given amount in the proper monetary format according to the locale.
 */
function _fm_monetize($amount, &$fmt = NULL) {
	return numfmt_format($fmt ? $fmt : _fm_nf_init(), $amount);
}

/**
 * Formatter-Helper
 *
 * @param amount
 * 	The amount... d'uh
 *
 * @param object fmt
 * 	The pre-initialized NumberFormatter object. If none given, initialize a new one.
 * 	
 * @return string 
 * 	The given amount in the proper number-format according to the locale
 */
function _fm_numerize($amount, &$fmt = NULL) {
	// Grab a formatter in case there's none.
	if (!$fmt) 
		$fmt = _fm_nf_init(NumberFormatter::DECIMAL);

	// Since we're not going with the currency format after all (don't ask)
	// we'll have to define the fraction-digits.
	numfmt_set_attribute($fmt, NumberFormatter::MAX_FRACTION_DIGITS, 2);
	numfmt_set_attribute($fmt, NumberFormatter::MIN_FRACTION_DIGITS, 2);

	return numfmt_format($fmt, $amount);
}

/**
 * Parse a numerical value
 *
 * @param amount
 * 	Guess what...
 *
 * @param fmt
 * 	Can recycle a formatter, default: DECIMAL
 *
 * @return
 * 	the parsed amount
 */
function _fm_parse_number($amount, &$fmt = NULL) {
	if (!$fmt) 
		$fmt = _fm_nf_init(NumberFormatter::DECIMAL);
	
	// Kill the currency symbol, just in case some genius entered it
	$amount = preg_replace('/' . _fm_cs($fmt) . '/', '', $amount);
	$amount = preg_replace('/\p{Z}/u', '', $amount);

	return numfmt_parse($fmt, $amount);
}

/**
 * Dump the current locale's currency-prefix / suffix
 *
 * @param bool psfix
 * 	Whataya want from me? TRUE == prefix, FALSE == suffix
 *
 * @param object fmt
 * 	The pre-initialized NumberFormatter object. If none given, initialize a new one.
 * 	
 * @return string
 * 	The monetary prefix / suffix for the selected locale
 */
function _fm_cs_psfix($psfix, &$fmt = NULL) {
	return numfmt_get_text_attribute($fmt ? $fmt : _fm_nf_init(), $psfix ? NumberFormatter::POSITIVE_PREFIX : NumberFormatter::POSITIVE_SUFFIX);
}


/**
 * Menu callback, User-Autocomplete function tailored to fratler_money's needs.
 *
 * @param string
 * 	A string to match against existing users
 *
 * @return
 * 	The list of matches in JSON format.
 */
function _fm_autocomplete($string = '', $direction = 'rid', $type) {
	global $user;
	$matches = array();
	$roles = array();

	if ($string) {
		// Ask the other modules what they think of it
		$matches += module_invoke_all('fm_autocomplete', $string, $direction, $type);

		$query = new EntityFieldQuery();
		$query->entityCondition('entity_type', 'fratler_money_account')
			->propertyCondition('name', '%' . $string . '%', 'LIKE')
			->propertyCondition('blocked', 0)	// No matter what permissions, blocked means blocked.
			->range(0, 10);
		if (!fratler_accounts_access(FAcPerm::IGNORE_BAR)) {
			$query->propertyCondition('active', 1);
			if ($direction == 'rid')
				$query->propertyCondition('state', FAcPerm::RECEIVE, '&');
		}
		$results = $query->execute();

		$candidates = fratler_money_account_load_multiple(array_keys($results['fratler_money_account']));

		foreach ($candidates as $candidate) {
			$matches[$candidate->name] = $candidate->name;

			// Attach a couple warning-messages to the display in case the accounts are blocked / inactive
			if (!$candidate->active)
				$matches[$candidate->name] .= ' ' . t('(inactive)');
		}

		drupal_json_output($matches);
	}
}

/**
 * Helper function to determine the proper way, an account-name should be displayed.
 *
 * @param account
 * 	the account-id
 *
 * @return
 * 	a string containing with the proper name
 */
function fratler_money_format_account($account) {
	if ($account > 0)
		return format_username(user_load($account));
	else if ($account < 0)
		return fratler_master_load($account)->name;
	return false;
}

/** 
 * Get the current balance of an account.
 *
 * @param account
 * 	The account-ID
 *
 * @return
 * 	The amount passed through _fm_numerize()
 */
function fm_get_balance($account, $tstamp = 0) {
	if ($tstamp == 0)
		return _fm_numerize(db_query('SELECT balance FROM {fratler_money_balances} WHERE aid = :aid', array(':aid' => $account), array('fetch' => PDO::FETCH_NUM))->fetchField());
	else
		return _fm_numerize(db_query('SELECT balance FROM {fratler_money_currents} WHERE rid = :aid AND tstamp >= :tstamp ORDER BY tstamp LIMIT 1', array(':aid' => $account, ':tstamp' => $tstamp), array('fetch' => PDO::FETCH_NUM))->fetchField());
	return _fm_numerize(0);
}

/**
 * Implements hook_fm_transaction_dry_run()
 * Run a test on a given transaction. This function checks,
 * if the involved parties have all required permissions and 
 * if any of the set limits (overdraw, transaction volume etc.) are violated.
 * NOTE: this is only run once per transaction-set, so in case there's a 
 * counter-transaction, we need to make sure that the counter-transaction is
 * up to standards.
 *
 * @param entity
 * 	The transaction-entity.
 *
 * @return
 * 	An array of error-messages with the error-code as key and the corresponding field as value (which can be recycled by form_set_error() etc.
 */
function fratler_money_fm_transaction_dry_run($entity) {
	global $user;

	// Before we start, check the integrity of the balances-db
	// TODO still need a cron-job to keep an eye on the signatures in both databases!

	// Step 1: grab the involved accounts
	$rid = fratler_money_account_load($entity->rid);
	$sid = fratler_money_account_load($entity->sid);

	// Step 2: check the signatures of the involved accounts
	// If the signatures don't match, shit has officially hit the fan.
	if (!$rid->signature_ok)  {
		return array(FMErrors::SIGNATURE_MISMATCH => 'rid');
	}

	if ($sid && !$sid->signature_ok) 
		return array(FMErrors::SIGNATURE_MISMATCH => 'sid');


	// prepare the error-container
	$errors = array();

	// Check permissions for adjustments
	if (!$entity->counter) {
		if ($entity->rid == $user->uid && !fratler_accounts_access(FAcPerm::ADJUST_OWN))
			$errors[FMErrors::PERM_ADJ_OWN] = 'rid';
		else if ($entity->rid != $user->uid && !fratler_accounts_access(FAcPerm::ADJUST_OTHER))
			$errors[FMErrors::PERM_ADJ_OTH] = 'rid';
	}

	// Check, if rid and sid are identical
	if ($entity->rid == $entity->sid) 
		$errors[FMErrors::RIDSID_IDENTICAL] = 'rid';

	// Check if the user is allowed to transfer own/other funds.
	// This is only relevant for transfers 
	// TODO implement the same for master-accounts, as this one only checks uids
	if ($entity->counter && $entity->sid > 0) {
		if ($entity->sid == $user->uid && !fratler_accounts_access(FAcPerm::TRANSFER_OWN))
			$errors[FMErrors::PERM_TRANS_OWN] = 'sid';
		else if ($entity->sid != $user->uid && !fratler_accounts_access(FAcPerm::TRANSFER_OTHER))
			$errors[FMErrors::PERM_TRANS_OTH] = 'sid';
	}

	// Check, if the recipient is allowed to receive transactions 
	// This only applies only for initial transfers, not the counter-transactions
	// TODO Make sure the implementation of FAcPerm in FMA ties in properly
	if ($entity->counter) {
		if (!fratler_accounts_access(FAcPerm::RECEIVE, $rid) && !fratler_accounts_access(FAcPerm::IGNORE_BAR)) {
			$errors[$rid->aid == $user->uid ? FMErrors::PERM_PART_OWN : FMErrors::PERM_PART_OTH] = 'rid';
		}
	}

	// If the amount is invalid or <= 0 and we're not adjusting
	if (!is_numeric($entity->amount) || ($entity->amount <= 0 && $entity->counter))
		$errors[FMErrors::AMOUNT_INVALID] = 'amount';

	// Check, if the amount exceeds the transaction-value and if the user's allowed to exceed it
	// fm_trans_max = 0 -> unlimited
	else if (abs($entity->amount) > variable_get('fm_trans_max') && variable_get('fm_trans_max') != 0 && 
			!fratler_accounts_access(FAcPerm::EXCEED_TRANS))
		$errors[FMErrors::AMOUNT_OVER_MAX] = 'amount';

	// Check the transaction-type for a pulse
	if (!taxonomy_term_load($entity->ttype))
		$errors[FMErrors::TTYPE_INVALID] = 'ttype';

	// Check for overdraw
	// If we're in a transfer and the sender overdraws (either < 0 or below the set overdraw-limit)
	// TODO: Implement the same for master-accounts as we're just doing the users here
	if ($entity->counter && $entity->sid > 0) {
		// Check if the sender is allowed to overdraw in general, in case the new balance is 0 > balance > limit
		if ($sid->balance-$entity->amount < 0 && $sid->balance-$entity->amount > variable_get('fm_overdraw_limit')) {
			if (!fratler_accounts_access(FAcPerm::OVERDRAW, $sid))
				$errors[$sid->aid == $user->uid ? FMErrors::OWN_OVERDRAW : FMErrors::SID_OVERDRAW] = 'amount';
		}
		// This is universal: check if the user has the permission to exceed the overdraw-limit
		if ($sid->balance-$entity->amount < variable_get('fm_overdraw_limit')) {
			if (!fratler_accounts_access(FAcPerm::EXCEED_OVERDRAW, $sid))
				$errors[$sid->aid == $user->uid ? FMErrors::OWN_OVERDRAW_EX : FMErrors::SID_OVERDRAW_EX] = 'amount';
		}

	// If we're adjusting and the recipient exceeds his overdraw
	// We're deducting -- this is to prevent deposits with the final balance still < overdraw_limit
	} else if (!$entity->counter && $entity->rid > 0 && $entity->amount < 0) {  								
		// Check if the user is allowed to overdraw in general, if the new balance is 0 > balance > limit
		if ($rid->balance+$entity->amount < 0 && $rid->balance+$entity->amount > variable_get('fm_overdraw_limit')) {
			if (!fratler_accounts_access(FAcPerm::OVERDRAW))
				$errors[FMErrors::OWN_OVERDRAW] = 'amount';
		}
		// This is universal: check if the user has permission to exceed the overdraw limit
		if ($rid->balance+$entity->amount < variable_get('fm_overdraw_limit')) {
			if (!fratler_accounts_access(FAcPerm::OVERDRAW))
				$errors[FMErrors::OWN_OVERDRAW_EX] = 'amount';
		}
	}


	return $errors;
}

/**
 * This holds the errors, that might occur during fm_dry_run()
 */
class FMErrors {
	const RIDSID_IDENTICAL 	= 0;	// rid and sid are identical
	const PERM_TRANS_OWN	= 1;	// The user is not allowed to transfer own funds
	const PERM_TRANS_OTH	= 2;	// The user is not allowed to transfer others' funds
	const PERM_PART_OWN	= 3;	// The user may not participate in transaction-system
	const PERM_PART_OTH	= 4;	// The other involved user may not participate in transaction-system
	const PERM_ADJ_OWN	= 6;	// The user may not adjust the own account
	const PERM_ADJ_OTH	= 7;	// The user may not adjust other accounts

	const AMOUNT_INVALID	= 10;	// The amount is invalid
	const AMOUNT_OVER_MAX	= 11;	// The amount exceeds max. transaction-volume

	const SID_OVERDRAW	= 20;	// The transaction will overdraw the sender's account
	const RID_OVERDRAW	= 21;	// The adjustment will overdraw the recipient's account
	const OWN_OVERDRAW	= 22;	// The transaction will overdraw the user's account
	const SID_OVERDRAW_EX	= 23;	// The transaction will exceed the overdraw-limit
	const RID_OVERDRAW_EX	= 24;	// The adjustment will exceed the recipient's account
	const OWN_OVERDRAW_EX	= 25;	// The transaction will exceed the user's account

	const TTYPE_INVALID	= 30;	// The transaction-type is invalid

	const SIGNATURE_MISMATCH = 666; // Congratulations, you're fucked!

}

/**
 * Provides the corresponding string to an error-code.
 *
 * @see FMErrors
 *
 * @param error
 * 	The error-code.
 *
 * @return
 * 	The corresponding string passed through t().
 */
function fm_get_error($error) {
	switch ($error) {
		case FMErrors::RIDSID_IDENTICAL:	return t('Recipient and Sender must not be identical.');
		case FMErrors::PERM_TRANS_OWN:		return t('You are not allowed to transfer your own funds.');
		case FMErrors::PERM_TRANS_OTH:		return t('You are not allowed to transfer others\' funds.');
		case FMErrors::PERM_PART_OWN:		return t('You are not allowed to participate in transactions.');
		case FMErrors::PERM_PART_OTH:		return t('This account is not allowed to participate in transactions.');
		case FMErrors::PERM_ADJ_OWN:		return t('You are not allowed to adjust your own account.');
		case FMErrors::PERM_ADJ_OTH:		return t('You are not allowed to adjust other accounts.');

		case FMErrors::AMOUNT_INVALID:		return t('Amount invalid.');
		case FMErrors::AMOUNT_OVER_MAX:		return t('Amount exceeds maximum transaction value.');

		case FMErrors::SID_OVERDRAW:		return t('This transaction will overdraw the sender\'s account.');
		case FMErrors::SID_OVERDRAW_EX:		return t('This transaction will exceed the sender\'s overdraw-limit.');
		case FMErrors::RID_OVERDRAW:		return t('This transaction will overdraw the account.');
		case FMErrors::RID_OVERDRAW_EX:		return t('This transaction will exceed the account\'s overdraw-limit.');
		case FMErrors::OWN_OVERDRAW:		return t('This transaction will overdraw your account.');
		case FMErrors::OWN_OVERDRAW_EX:		return t('This transaction will exceed your overdraw-limit.');

		case FMErrors::TTYPE_INVALID:		return t('The transaction-type is invalid.');

		case FMErrors::SIGNATURE_MISMATCH:	''; #return t('Signature mismatch detected. Please contact an administrator immediately!');

		default: return t('An unknown error occured. Your transaction could not be completed.');
	}
}


function fratler_money_reassign($master, $target, $redirect = null, $last_words = array()) {
	$merger = _fm_reassign_queue($master, $target, $last_words);
	if (!$merger) {
		error_log("ABORT ABORT ABORT!!!");
		return $redirect ? drupal_goto_redirect($redirect) : false;
	}
	$runner = array(
		'operations' 	=> $merger,
		'finished'	=> '_fm_reassign_done',
		'title'		=> t('Rebooking account %from to %to', array('%from' => $master->name, '%to' => $target->name)),
	);

	batch_set($runner);
	if  ($redirect)
		batch_process($redirect);
}

function _fm_reassign_queue($acc_from, $acc_to) {
	$merger = array();
	$sigs_ok = true;

	$tids_from = fratler_money_get_transactions($acc_from->aid);
	$transactions_from = fratler_money_transaction_load_multiple($tids_from);

	$tids_to = fratler_money_get_transactions($acc_to->aid, empty($transactions_from) ? array() : reset($transactions_from)->tstamp);
	$transactions_to = fratler_money_transaction_load_multiple($tids_to);

	// Since we get the counter-transactions inverted, we need to shift them back
	foreach ($transactions_to as $to) {
		if ($to->amount < 0 && $to->sid != 0) {
			$to->sid ^= $to->rid ^= $to->sid ^= $to->rid;
		}

		$sigs_ok = $sigs_ok & $to->signature_ok;
	}

	foreach ($transactions_from as $from) {
		if ($from->amount < 0 && $from->sid <> 0) 
			$from->sid ^= $from->rid ^= $from->sid ^= $from->rid;

		$sigs_ok = $sigs_ok & $from->signature_ok;
	}

	// If one of the signature checks failed, cancel the whole thing
	if (!$sigs_ok)
		return false;

	// Step 1: Initialize the context
	$merger[] = array(
		'_fm_reassign_process',
		array('op' => 'init', 
			array(
				'aid_from' 	=> $acc_from->aid,
				'name_from'	=> $acc_from->name,
				'aid_to' 	=> $acc_to->aid, 
				'name_to'	=> $acc_to->name,
				'tstamp_merge'	=> time(),
				'balance_to' 	=> fm_get_balance($acc_to->aid, empty($transactions_from) ? 0 : reset($transactions_from)->tstamp),
			),
		));
	if ($transactions_from) {
		foreach ($transactions_from as $key_from => $from) {
			// Attach the target account's transactions to the queue that need to be updated (stuff...)
			foreach ($transactions_to as $key_to => $to) {
				// Only transactions that affect the balance are relevant
				if ($to->tstamp <= $from->tstamp && $to->rid == $acc_to->aid) {
					$merger[] = array('_fm_reassign_process', array('op' => 'update', 'transaction' => $to));
					unset($transactions_to[$key_to]);
				}
			}

			$merger[] = array('_fm_reassign_process', array('op' => 'reassign', 'transaction' => $from));
			unset($transactions_from[$key_from]);
		}
		// Slap the remaining target transactions to the ops-array
		foreach ($transactions_to as $key => $to) {
			if ($to->rid == $acc_to->aid) {
				$merger[] = array('_fm_reassign_process', array('op' => 'update', 'transaction' => $to));
				unset($transactions_to[$key]);
			}
		}
	}

	// Last job: update the new account's balance
	$merger[] = array('_fm_reassign_process', array('op' => 'update_balances', null));

	return $merger;
}

function _fm_reassign_done($success, $results, $ops) {
	if ($success) {
		foreach ($results['messages'] as $message)
			drupal_set_message($message, 'status');
	}
	else
		drupal_set_message(t('Well... this is embarassing. Could not finish the job. Ask your admin for help. Sorry!'));
	
}

function _fm_reassign_process($op, $data, &$context) {
	global $user;

	// Set up context and fill it with the relevant data
	// aid_from	The old account id
	// name_from	The name of the new account
	// aid_to	The new account id
	// name_to	The name of the new account
	// balance_to	The last balance of the new account before the first transaction of the old account
	// tstamp_merge	The timestamp when the merge occured
	if ($op == 'init') {
		$context['results']['log'] 	= array();
		$context['results']['counter'][$data['name_to']]	= 0;
		$context['results']['conf']	= $data;
	}

	// Update the FMAcs 
	elseif ($op == 'update_balances') {
		$acc_from 	= fratler_money_account_load($context['results']['conf']['aid_from']);
		$acc_to		= fratler_money_account_load($context['results']['conf']['aid_to']);

		// Reset old account
		$acc_from->last_trans = $acc_from->tstamp = $acc_from->balance = 0;
		fratler_money_account_save($acc_from);

		// Update new account
		$acc_to->balance 	= $context['results']['conf']['balance_to'];
		$acc_to->tstamp 	= $context['results']['conf']['tstamp_last'];
		$acc_to->last_trans 	= $context['results']['conf']['tid_last'];
		fratler_money_account_save($acc_to);

		$context['results']['messages'][] = format_plural((int)$context['results']['counter'][$data['name_to']], 
				'Rebooked one transaction from %old to %new.', 
				'Rebooked @count transactions from %old to %new.',
				array('%old' => $context['results']['conf']['name_from'], '%new' => $context['results']['conf']['name_to']));
	}

	// Reassign a transaction to new account and do the necessary calculations
	elseif ($op == 'reassign') {
		// Old account was recipient; this means change rid and balance
		if ($data->rid == $context['results']['conf']['aid_from']) {
			$data->rid = $context['results']['conf']['aid_to'];
			$data->balance = $context['results']['conf']['balance_to'] = $context['results']['conf']['balance_to'] + $data->amount;
		}

		// The old account was the sender, all we need to do here is change the sid
		if ($data->sid == $context['results']['conf']['aid_from']) {
			$data->sid = $context['results']['conf']['aid_to'];
		}

		// If, by some freakish coincidence, we end up transferring stuff to the same account, reset the counter-balance (cosmetics only)
		if ($data->sid == $data->rid && $data->amount < 0)
			$data->balance = $context['results']['conf']['balance_to'];

		// Add a snappy message to let the user know what happened.
		$data->txt .= '<br/>'. t('[%old &#8594; %new on @date by @user]', 
			array('%old' => $context['results']['conf']['name_from'], 
				'%new' => $context['results']['conf']['name_to'], 
				'@date' => format_date($context['results']['conf']['tstamp_merge'], 'short'), 
				'@user' => format_username($user)));
		
		// We will save this at some point, but for now just dump it as log in $context
		fratler_money_transaction_save($data);
		$context['results']['log'][]  = array($op, $data);
		$context['results']['conf']['tstamp_last']  = $data->tstamp;
		$context['results']['conf']['tid_last']  = $data->tid;
		$context['results']['counter'][$data->name]++;
	}

	// Update the balance of the new account if necessary
	elseif ($op == 'update') {
		// Only transactions that affect the balance are relevant
		if ($data->rid == $context['results']['conf']['aid_to']) {
			$data->balance = $context['results']['conf']['balance_to'] = $context['results']['conf']['balance_to'] + $data->amount;
			fratler_money_transaction_save($data);
			$context['results']['log'][]  = array($op, $data);
			$context['results']['conf']['tstamp_last']  = $data->tstamp;
			$context['results']['conf']['tid_last']  = $data->tid;
			$context['results']['counter'][$data->name]++;
		}
	}

}
